<!-- 算法题刷题记录 -->
# 简单回顾旅程

## 日记表格

## 记录
| 序号 | 时间 | 题目 | 知识点 | 难度 | 自行是否做出 | 是否理解 | 有几种方法 | 备注 |
| ---- | ---- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 2021.2.26 | [1178. 猜字谜](#2021-2-26) | 位压缩 | 困难 | 超时TT | 暂未全部理解 | 2 |  |
| 2 | 2021.3.1 | [303. 区域和检索-数组不可变](#2021-3-1) | 前缀和 | 简单 | 是 | 理解 | 3 |  |
| 3 | 2021.3.2 | [304. 二维区域和检索-矩阵不可变](#2021-3-2) | 前缀和 | 中等 | 是 | 理解 | 2 |  |
| 4 | 2021.3.5 | [232. 用栈实现队列](#2021-3-5) | 模拟队列 | 简单 | 是 | x(直接用数组实现的##) |  |
| 5 | 2021.3.5 | [338. 比特位计数](#2021-3-5) | 位运算 + 动态规划 | 中等 | 是 | 是 | 3 | 补偿 |
| 6 | 2021.3.5 | [354. 俄罗斯套娃信封问题](#2021-3-5) | 二分查找 + 动态规划 | 困难 | 否 | 否 | 2 | 补卡 |
| 7 | 2021.3.8 | [132. 分割回文串II](#2021-3-8) | 滑动窗口 + 动态规划 | 困难 | 否 | 否 | 2 |  |
| 8 | 2021.3.9 | [1047. 删除字符串中的所有相邻重复项](#2021-3-9) | 简单数据结构 - 栈/队列 | 简单 | 是 | 是 | 5 | 主要是用栈、队列 |
| 9 | 2021.3.10 | [224. 基本计算器](#2021-3-10) | 括号展开 + 栈 | 困难 | 否 | 否 | 1 |  主要是利用 栈 |
| 10 | 2021.3.11 | [227. 基本计算器](#2021-3-11) II | 栈 | 中等 | 是 | 还行 | 1 | 复习昨天 |
| 11 | 2021.3.12 | [331. 验证二叉树的前序序列化](#2021-3-12) | 栈 | 中等 | 否 | 否 | 2 | 没看懂题目 |
| 12 | 2021.3.15 | [54. 螺旋矩阵](#2021-3-15) | 模拟、按层模拟 | 中等 | 否 | 否 | 2 | 看懂题目，突然不知道怎么组织代码 |
| 13 | 2021.3.16 | [59. 螺旋矩阵II](#2021-3-16) | 模拟、按层模拟 | 中等 | cv | 否 | 2 | 昨天一样 |
| 14 | 2021.3.17 | [115. 不同的子序列](#2021-3-17) | 动态规划 | 困难 | cv | 否 | 1 | TT至今没有看 |  
| 15 | 2021.3.18 | [92. 反转链表II](#2021-3-18) | 反转链表 | 中等 | 是 | 是 | 1 | 链表知识，由于c语言指针一点都不可怕，所以慢慢分析，虽然代码可能比较臃肿 |
| 16 | 2021.3.19 | [1603. 设计停车系统](#2021-3-19) | 数组或者... | 简单 | 是 | 是 | 2 | 非常简单的构造一个类，考虑数据结构就可以，够用即可 |
| 17 | 2021.3.22 | [191. 位1的个数](#2021-3-22) | 位运算 | 简单 | 是 | 否 | 1 | 最近脑子瓦特了 |
| 18 | 2021.3.23 | [341. 扁平化嵌套列表迭代器](#2021-3-23) | 栈或者DFS递归 | 中等 | 否 | 否 | 2 | 没有能够组织好思路，编写代码，但是知道有这两个方法 |
| 19 | 2021.3.24 | [456. 132模式](#2021-3-24) | 单调栈、二分查找 | 中等 | 否 | 否 | 3 | 没有想到枚举每个3 |
| 20 | 2021.3.25 | [82. 删除排序链表中的重复元素II](#2021-3-25) | 链表操作 | 中等 | 是 | 是 | 1 |  |
| 21 | 2021.3.26 | [83. 删除排序链表中的重复元素](#2021-3-26) | 链表操作 | 简单 | 是 | 是 | 1 |  |
| 22 | 2021.3.29 | [190. 颠倒二进制位](#2021-3-29) | 位操作 | 简单 | 否 | 否 | 1 |  |
| 23 | 2021.3.30 | [74. 搜索二维矩阵](#2021-3-30) | 二分查找 | 中等 | 是 | 是 | 2 |  |
| 24 | 2021.3.31 | [90. 子集II](#2021-3-31) | 子集枚举 | 中等 | 否 | 否 | 2 |  |
| 25 | 2021.4.1 | [1006. 笨阶乘](#2021-4-1) | 栈或数学 | 中等 | 是 | 是 | 2 |  |
| 26 | 2021.4.2 | [面试题 17.21. 直方图的水量](#2021-4-2) | 动态规划或单调栈或者双指针 | 困难 | 否 | 否 | 3 |  |
| 27 | 2021.4.8 | [153. 寻找旋转排序数组中的最小值](#2021-4-8) | 二分查找 | 中等 | 是 | 是 | 1 |  |
| 28 | 2021.4.9 | [154. 寻找旋转排序数组中的最小值](#2021-4-9) II | 二分查找 | 困难 | 是 | 是 | 1 |  |
| 29 | 2021.4.12 | [179. 最大数](#2021-4-12) | 排序 | 中等 | 是 | 是 | 1 |  |
| 30 | 2021.4.13 | [783. 二叉搜索树节点最小距离](#2021-4-13) | 遍历 | 简单 | 否 | 是 | 1 |  |
| 31 | 2021.4.14 | [208.实现Trie(前缀树)](#2021-4-14) | 前缀树 | 中等 | 是 | 否 | 1 |  |
| 32 | 2021.4.15 | [213. 打家劫舍](#2021-4-15) II | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 33 | 2021.4.16 | [87. 扰乱字符串](#2021-4-16) | 动态规划 | 困难 | 否 | 否 | 1 |  |
| 34 | 2021.4.19 | [27. 移除元素](#2021-4-19) | 双指针 | 简单 | 是 | 是 | 1 |  |
| 35 | 2021.4.20 | [28. 实现strStr](#2021-4-20)() | 字符串匹配方法 | 简单 | 是 | 是 | 2+ |  |
| 36 | 2021.4.21 | [91. 解码方法](#2021-4-21) | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 37 | 2021.4.22 | [363. 矩形区域不超过K的最大数值和](#2021-4-22) | 有序集合 | 困难 | 否 | 否 | 1 | 及其难，想不出来，也没看懂 |
| 38 | 2021.4.23 | [368. 最大整除子集](#2021-4-23) | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 39 | 2021.4.25 | [897. 递增顺序搜索树](#2021-4-25) | 动态规划 | 简单 | 否 | 否 | 1 |  |
| 40 | 2021.4.26 | [1011. 在D天内送达包裹的能力](#2021-4-26) | 二分查找 | 中等 | 否 | 否 | 1 |  |
| 41 | 2021.4.27 | [938. 二叉搜索树的范围和](#2021-4-27) | 树的遍历 | 简单 | 是 | 是 | 2 |  |
| 42 | 2021.4.28 | [633. 平方数之和](#2021-4-28) | 双指针\数学(因式分解)\sqrt函数 | 中等 | 是 | 是 | 3 |  |
| 43 | 2021.4.29 | [403. 青蛙过河](#2021-4-29) | 记忆化搜索\动态规划 | 困难 | 否 | 否 | 2 |  |
| 44 | 2021.5.6 | [1720. 解码异或后的数组](#2021-5-6) | 异或 | 简单 | 是 | 是 | 1 |  |
| 45 | 2021.5.7 | [1486. 数组异或操作](#2021-5-7) | 异或 | 简单 | 是 | 是 | 2 |  |
| 46 | 2021.5.8 | [1723. 完成所有工作的最短时间](#2021-5-8) | 全遍历的一些方法 | 困难 | 否 | 否 | 2 |  |
| 47 | 2021.5.10 | [872. 叶子相似的树](#2021-5-10) | 树的遍历 | 简单 | 是 | 是 | 1 |  |
| 48 | 2021.5.11 | [1734. 解码异或后的排列](#2021-5-11) | 异或 | 中等 | 否 | 是 | 1 |  |
| 49 | 2021.5.12 | [1310. 子数组异或查询](#2021-5-12) | 异或 | 中等 | 是 | 是 | 2 | 噗, 我竟然没有超时, 很不错!! |
| 50 | 2021.5.13 | [1269. 停在原地的方案数](#2021-5-13) | 动态规划 | 困难 | 否 | 否 | 1 |  |
| 51 | 2021.5.14 | [12. 整数转罗马数字](#2021-5-14) | 模拟，硬编码数字 | 中等 | 否 | 否 | 1 |  |
| 52 | 2021.5.19 | [](#2021-5-19) |  | 中等 | 否 | 否 | 1 | 这几天比较忙，项目比较急，需要加班，刷题狼心狗肺，异或-前缀和方法。 |
| 53 | 2021.5.20 | [692. 前K个高频单词](#2021-5-20) | hash + 排序 | 中等 | 是 | 是 | 2 | 发现自己的事还是比较重要的，跟着产品经理后面的活永远干不完，而且还只会吩咐别人干 |
| 54 | 2021.5.21 | [1035. 不相交的线](#2021-5-21) | dp动态规划 | 中等 | 是 | 是 | 1 | 只要需要全遍历的都应该想到这个，但是不会 |
| 55 | 2021.5.24 | [664. 奇怪的打印机](#2021-5-24) | dp动态规划 | 困难 | 否 | 否 | 1 |  |
| 56 | 2021.5.25 | [1787. 使所有区间的异或结果为零](#2021-5-25) | dp动态规划 | 困难 | 否 | 否 | 1 |  |
| 57 | 2021.5.26 | [1190. 反转每对括号间的子串](#2021-5-26) | 栈、预处理 | 中等 | 否 | 否 | 2 | 傻了 |
| 58 | 2021.5.27 | [461. 汉明距离](#2021-5-27) | 位运算 | 简单 | 是 | 是 | 2 |  |
| 59 | 2021.5.28 | [477. 汉明距离总和](#2021-5-28) | 逐位统计 | 中等 | 否 | 是 | 1 |  |
| 60 | 2021.5.31 | [342. 4的幂](#2021-5-31) | 二进制位、取模性质 | 简单 | 否 | 否 | 2 |  |
| 61 | 2021.6.1 | [1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](#2021-6-1) | 前缀和 | 中等 | 否 | 否 | 1 |  |
| 62 | 2021.6.2 | [523. 连续的子数组和](#2021-6-2) | 前缀和+哈希表 | 中等 | 否 | 否 | 1 |  |
| 63 | 2021.6.3 | [525. 连续数组](#2021-6-3) | 前缀和+哈希表 | 中等 | 否 | 否 | 1 |  |
| 64 | 2021.6.7 | [494. 目标和](#2021-6-7) | 动态规划、回溯 | 中等 | 否 | 否 | 1 |  |
| 65 | 2021.6.8 | [1049. 最后一块石头的重量 II](#2021-6-8) | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 66 | 2021.6.9 | [879. 盈利计划](#2021-6-9) | 动态规划 | 困难 | 否 | 否 | 1 |  |
| 67 | 2021.6.10 | [518. 零钱兑换 II](#2021-6-10) | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 68 | 2021.6.11 | [279. 完全平方数](#2021-6-11) | 动态规划 | 中等 | 否 | 否 | 1 |  |
| 69 | 2021.6.15 | [852. 山脉数组的峰顶索引](#2021-6-15) | 枚举、二分查找 | 简单 | 是 | 是 | 2 |  |
| 70 | 2021.6.16 | [877. 石子游戏](#2021-6-16) | 数学、动态规划 | 中等 | 否 | 是 | 2 |  |
| 71 | 2021.6.17 | [65. 有效数字](#2021-6-17) | 确定有限状态自动机 | 困难 | 否 | 否 | 1 |  |
| 72 | 2021.6.18 | [483. 最小好进制](#2021-6-18) | 数学 | 困难 | 否 | 否 | 1 |  |
| 73 | 2021.11.15 | [319. 灯泡开关](#2021-11-15) | 数学规律 | 中等 | 否 | 否 | 1 |  |
| 74 | 2021.11.16 | [391. 完美矩形](#2021-11-16) | 哈希... | hard | 否 | 否 | 1 |  |
| 75 | 2021.11.17 | [318. 最大单词长度乘积](#2021-11-17) | 遍历... | middle | 是 | 是 | 3+ |  |

 
## 已做内容

### <div id="2021-2-26">2021.2.26</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/)

#### 题目理解：
```javascript
/**
* 计算一个单词的谜底数量：
*    包含首字母，谜底中的字母存在在谜面上
* 怎么缩小全部计算的计算量呢？
*    先用  某 class(数据结构) 分析下当前的单词？‘
*    以方便比较？
*    给字母排序？
*/
```

#### 解决办法：
1. 自己的解法，超时，用的 Map 数据结构来解决的，最后一个测试案例通不过
```javascript
/**
 * @param {string[]} words
 * @param {string[]} puzzles
 * @return {number[]}
 */
var findNumOfValidWords = function(words, puzzles) {
    /**
     * 计算一个单词的谜底数量：
     *    包含首字母，谜底中的字母存在在谜面上
     * 怎么缩小全部计算的计算量呢？
     *    先用  某 class(数据结构) 分析下当前的单词？‘
     *    以方便比较？
     *    给字母排序？
     */
    var res = []
    var ws = []
    for (var i = 0; i < words.length; i++) {
        ws.push(new Word(words[i]))
    }
    for (var i = 0; i < puzzles.length; i++) {
        var count = 0;
        var word = new Word(puzzles[i])
        for (var j = 0; j < ws.length; j++) {
            if (ws[j].find(puzzles[i][0]) && word.compare(ws[j].map)) {
                count += 1
            }
        }
        res.push(count)
    }
    return res
};
class Word {
    constructor(word) {
        this.map = new Map()
        for (var i = 0; i < word.length; i++) {
            this.map.set(word[i], 1)
        }
    }

    find(char) {
        return this.map.has(char)
    }

    compare(mapW) {
        if (mapW.size > this.map.size) return false
        for (let key of mapW.keys()) {
            if (!this.map.has(key))  {
                return false
            }
        }
        return true
    }
}
```

2. 二进制位压缩 --- 某个大佬的 answer
```javascript 
/**
 * @param {string[]} words
 * @param {string[]} puzzles
 * @return {number[]}
 */
var findNumOfValidWords = function(words, puzzles) {
     const map = {}; // 存放所有单词对应的二进制数
    for (const word of words) { // 遍历单词表
        const bit = getBit(word); // 单词对应的二进制数
        if (map[bit] === undefined) { // 存入map，统计出现次数
            map[bit] = 1;
        } else {
            map[bit]++;
        }
    }
    const res = new Array(puzzles.length).fill(0); // 待返回的数组，所有puzzle的谜底数量
    for (let i = 0; i < puzzles.length; i++) { // 遍历谜语
        const puzzleBit = getBit(puzzles[i]); // 当前谜语的二进制数
        const first = getBit(puzzles[i][0]); // 谜语的第一个字符对应的二进制数，比如c就是100

        let n = puzzleBit; // n初始为puzzleBit这个组合
        while (n > 0) { // 遍历puzzle的所有字母组合，当n=0时终止遍历
            // 按位都是1才为1，否则为0，即n这个组合包含puzzle的首字母
            // 而且n这个组合在map中有值，即有单词长n这样，值累加给res[i]
            if ((n & first) != 0 && map[n] > 0) {
                res[i] += map[n];
            }
            // n-1 AND puzzleBit，生成一个puzzleBit的新的子集合
            n = (n - 1) & puzzleBit;
        }
    }
    return res;
};
// word转成用二进制数表示的字符集合
function getBit(word) {
    let res = 0;
    for (const c of word) {
        const offset = c.charCodeAt(0) - 97; // a在最低位，求出当前字符的偏移位
        const status = 1 << offset; // 将二进制的1左移offset位，右边用0填充
        res = res | status; // 按位或，该位至少有一个1时，才为1（出现过），否则为0
    }
    return res;
}
```

3. 官方题解 - 二进制压缩
```javascript
/**
 * @param {string[]} words
 * @param {string[]} puzzles
 * @return {number[]}
 */
var findNumOfValidWords = function(words, puzzles) {
    const frequency = new Map();

    for (const word of words) {
        let mask = 0;
        for (const ch of word) {
            mask |= (1 << (ch.charCodeAt() - 'a'.charCodeAt()));
        }
        if (CountOne(mask) <= 7) {
            frequency.set(mask, (frequency.get(mask) || 0) + 1);
        }
    }

    const ans = [];
    for (const puzzle of puzzles) {
        let total = 0;

        // 枚举子集方法一
        // for (let choose = 0; choose < (1 << 6); ++choose) {
        //     let mask = 0;
        //     for (let i = 0; i < 6; ++i) {
        //         if (choose & (1 << i)) {
        //             mask |= (1 << (puzzle[i + 1].charCodeAt() - 'a'.charCodeAt()));
        //         }
        //     }
        //     mask |= (1 << (puzzle[0].charCodeAt() - 'a'.charCodeAt()));
        //     if (frequency.has(mask)) {
        //         total += frequency.get(mask);
        //     }
        // }
        // 枚举子集方法二
        let mask = 0;
        for (let i = 1; i < 7; ++i) {
            mask |= (1 << (puzzle[i].charCodeAt() - 'a'.charCodeAt()));
        }
        let subset = mask;
        while (subset) {
            let s = subset | (1 << (puzzle[0].charCodeAt() - 'a'.charCodeAt()));
            if (frequency.has(s)) {
                total += frequency.get(s);
            }
            subset = (subset - 1) & mask;
        }
        // 在枚举子集的过程中，要么会漏掉全集 mask，要么会漏掉空集
        // 这里会漏掉空集，因此需要额外判断空集
        if (frequency.has(1 << (puzzle[0].charCodeAt() - 'a'.charCodeAt()))) {
            total += frequency.get(1 << (puzzle[0].charCodeAt() - 'a'.charCodeAt()));
        }
        ans.push(total);
    }
    return ans;
};

function CountOne(n) {
    const str = n.toString(2);
    let count = 0;
    for (const ch of str) {
        if (parseInt(ch) === 1) {
            count++;
        }
    }
    return count;
}
```


#### 其他：
1. 合理利用题目给出的条件
2. 丝毫没有想到 <em><strong>二进制位压缩</strong></em> 来记录，只想到 map 来记录，顺序是否考虑感觉不是那么重要，该用的循环都用了

### <div id="2021-3-1">2021.3.1</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/range-sum-query-immutable/)

#### 题目理解：
```javascript
/**
* 实现一个类
* 原型链上实现一个简单计算的函数（肯定是要对数组遍历一遍的）
*/
```

#### 解决办法：
主要理解 prototype ：   
定义一个简单的类 :   
```javascript
function MyClass() {

};
```
给类增加属性和方法 :    
```javascript
// 添加属性用 this 
function MyClass(name, age) {
  // 属性
  this.name = name;
  this.age = age;
  // 方法
  this.toString() = function(){
    alert(this.name +":"+ this.age);
  };
};
```
每一个函数都会包含一个 prototype 属性，这个属性指向了一个prototype对象，我们可以指定函数对应的 prototype 对象。如果不指定，则函数的 prototype 属性将指向一个默认的 prototype 对象，并且次默认的 prototype 对象的 constructor 属性又会指向该函数。
当用构造函数创建一个新的对象时，新的对象会获取构造函数的 prototype 属性所指向的 prototype 对象的所有属性和方法，这样一来，构造函数对应的 prototype 对象所做的任何操作都会反映到它所生成的对象上，所有的这些对象将共享与构造函数对应的 prototype 对象的属性和方法。
虽然新创建的对象可以使用它的构造函数所指向的 prototype 对象的属性和方法，但不能像构造函数那样直接调用 prototype 对象（对象没有 prototype 属性）。
简而言之，就是如果我们使用函数的 prototype 对象来给函数添加方法，那么在创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这函数的所有方法。
```javascript
function MyClass(name,age){
  this.name = name;
  this.age = age;
}
// 利用 prototype 来实现封装的, 给类添加方法的实现
MyClass.prototype = {
  toString:function(){
    //
  },
  sayHellow:function(){
    //
  }
};
var cls1 = new MyClass("liming",10);
cls1.toString(); //
var cls2 = new MyClass("zhang",10);
cls2.toString();
```


1. 直接写
```javascript
var NumArray = function(nums) {
    this.array = nums
};

NumArray.prototype.sumRange = function(i, j) {
    var sum = 0
    for (var index = i; index <= j; index++) {
        sum += this.array[index]
    }
    return sum
};
```

2. 官方题解 - 前缀和
```javascript
var NumArray = function(nums) {
    const n = nums.length;
    this.sums = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        this.sums[i + 1] = this.sums[i] + nums[i];
    }
};

NumArray.prototype.sumRange = function(i, j) {
    return this.sums[j + 1] - this.sums[i];
};
```

3. 分块来优化暴力
```C++
class NumArray {
private:
    static constexpr int block_size = 100;
    vector<int> nums;
    vector<int> block_sum;

public:
    NumArray(vector<int>& nums) {
        this->nums = nums;

        int i = 0;
        while (i + block_size <= nums.size()) {
            block_sum.push_back(accumulate(nums.begin() + i, nums.begin() + i + block_size, 0));
            i += block_size;
        }
    }
    
    int sumRange(int i, int j) {
        int k = i, ans = 0;
        while (k <= j) {
            if (k % block_size == 0 && k + block_size - 1 <= j) {
                ans += block_sum[k / block_size];
                k += block_size;
            }
            else {
                ans += nums[k];
                ++k;
            }
        }
        return ans;
    }
};
```



#### 其他：
nothing...  

### <div id="2021-3-2">2021.3.2</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

#### 题目理解：
```
/**
 * 昨天是数组不可变, 使用的方法是前缀和
 * 今天也是的, 应该.
 */
```

#### 解决办法：
1. 照昨天的理解写
```javascript
/**
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
    /**
     * 昨天是数组不可变, 使用的方法是前缀和
     * 今天也是的, 应该.
     */
    this.matrix = matrix
    this.sumMatrix = matrix
    for (var i = 0; i < this.sumMatrix.length; i++) {
        for (var j = 0; j < this.sumMatrix[i].length; j++) {
            if (j >= 1) {
                if (i >= 1) {
                    this.sumMatrix[i][j] = matrix[i][j] + this.sumMatrix[i - 1][j] + this.sumMatrix[i][j - 1]
                        - this.sumMatrix[i - 1][j - 1]
                } else {
                    this.sumMatrix[i][j] += this.sumMatrix[i][j - 1]
                }
            } else {
                if (i >= 1) {
                    this.sumMatrix[i][j] += this.sumMatrix[i - 1][j]
                }
            }
        }
    }
};

/** 
 * @param {number} row1 
 * @param {number} col1 
 * @param {number} row2 
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
    if (row1 === 0) {
        if (col1 === 0) {
            return this.sumMatrix[row2][col2]
        } else {
            return this.sumMatrix[row2][col2] - this.sumMatrix[row2][col1 - 1]
        }
    } else {
        if (col1 === 0) {
            return this.sumMatrix[row2][col2] - this.sumMatrix[row1 - 1][col2]
        } else {
            return this.sumMatrix[row2][col2] - this.sumMatrix[row2][col1 - 1] 
            - this.sumMatrix[row1 - 1][col2] + this.sumMatrix[row1 - 1][col1 - 1] 
        }
    }
};
```

2. 官方题解 - [一维|二维]前缀和
```javascript
var NumMatrix = function(matrix) {
    const m = matrix.length;
    if (m > 0) {
        const n = matrix[0].length;
        this.sums = new Array(m).fill(0).map(() => new Array(n + 1).fill(0));
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                this.sums[i][j + 1] = this.sums[i][j] + matrix[i][j];
            }
        }
    }
};

NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
    let sum = 0;
    for (let i = row1; i <= row2; i++) {
        sum += this.sums[i][col2 + 1] - this.sums[i][col1];
    }
    return sum;
};
```

#### 其他：
考验对昨天知识点的理解

### <div id="2021-3-5">2021.3.5</div>
- 栈实现队列 : 简单

- 比特为计数
    #### 题目描述：
    [描述](https://leetcode-cn.com/problems/counting-bits/)

    #### 题目理解：
    ```javascript
    /**
    * 需要看每个数的二进制值组成,然后计算
    * 位运算：
    * 1. & 同1为1
    * 2. | 同0为0
    * 3. ~ 取反
    * 4. ^(异或) 同为0，异为1
    */
    ```

    #### 解决办法：
    1. 直接计算
    ```javascript
    /**
    * @param {number} num
    * @return {number[]}
    */
    var countBits = function(num) {
        /**
        * 需要看每个数的二进制值组成,然后计算
        * 位运算：
        * 1. & 同1为1
        * 2. | 同0为0
        * 3. ~ 取反
        * 4. ^(异或) 同为0，异为1
        */
        var res = []
        for (var i = 0; i <= num; i++){
            var tnum = i
            var c = 0
            // while(tnum > 0) { 
            while((tnum | 0) !== 0) { 
                c += tnum & 1
                tnum = tnum >> 1
            }
            res.push(c)
        }
        return res
    };
    ```

    2. 官方题解 -> 动态规划
    ```javascript 
    // 最高有效位
    /**
    * i & (i - 1)可以去掉i最右边的一个1（如果有），因此 i & (i - 1）是比 i 小的，
    * 而且i & (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i & (i - 1)的1的个数加上1
    **/
    var countBits = function(num) {
        const bits = new Array(num + 1).fill(0);
        let highBit = 0;
        for (let i = 1; i <= num; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    };

    // 最低有效位
    /**
    * i >> 1会把最低位去掉，因此i >> 1 也是比i小的，同样也是在前面的数组里算过。
    * 当 i 的最低位是0，则 i 中1的个数和i >> 1中1的个数相同；当i的最低位是1，
    * i 中1的个数是 i >> 1中1的个数再加1
    **/
    var countBits = function(num) {
        const bits = new Array(num + 1).fill(0);
        for (let i = 1; i <= num; i++) {
            bits[i] = bits[i >> 1] + (i & 1);
        }
        return bits;
    };
    ```

    #### 其他：
    1. 理解前面算过的与后面的联系

- 俄罗斯套娃信封问题
    #### 题目描述：
    [描述](https://leetcode-cn.com/problems/russian-doll-envelopes/)

    #### 题目理解：
    ```javascript
     /**
     * 先按照 x，y 排序？
     */
    var res = 1
    envelopes.sort(function (o1, o2) {
        if (o1[0] === o2[0]) {
            return o1[1] - o2[1]
        } else {
            return o1[0] - o2[0]
        }
    })
    /**
     * 然后动态规划？不会
     * 从大的开始，尽量选接近的套 - > 怎么判断尽量接近呢 ？ 
     * 答案是错的！！！
     * 因为不是最佳路径
     */
    for (var j = envelopes.length - 1; j > 0; j--) {
        var sum = 1
        var cur = j
        for (var i = cur - 1; i >= 0; i--) {
            if (envelopes[cur][0] > envelopes[i][0] && envelopes[cur][1] > envelopes[i][1]) {
                sum += 1
                cur = i
            }
        }
        if (sum > res) {
            res = sum
        }
        console.log(j)
        console.log(res)
    }
    return res
    ```

    #### 解决办法：
    1. 官方题解 -> 动态规划
    ```javascript 
    // 直接动态规划
    var maxEnvelopes = function(envelopes) {
        if (envelopes.length === 0) {
            return 0;
        }
        
        const n = envelopes.length;
        envelopes.sort((e1, e2) => {
            if (e1[0] !== e2[0]) {
                return e1[0] - e2[0];
            } else {
                return e2[1] - e1[1];
            }
        })

        const f = new Array(n).fill(1);
        let ans = 1;
        for (let i = 1; i < n; ++i) {
            for (let j = 0; j < i; ++j) {
                if (envelopes[j][1] < envelopes[i][1]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            ans = Math.max(ans, f[i]);
        }
        return ans;
    };
    // 二分查找 + 动态规划
    var maxEnvelopes = function(envelopes) {
        if (envelopes.length === 0) {
            return 0;
        }
        
        const n = envelopes.length;
        envelopes.sort((e1, e2) => {
            if (e1[0] - e2[0]) {
                return e1[0] - e2[0];
            } else {
                return e2[1] - e1[1];
            }
        })

        const f = [envelopes[0][1]];
        for (let i = 1; i < n; ++i) {
            const num = envelopes[i][1];
            if (num > f[f.length - 1]) {
                f.push(num);
            } else {
                const index = binarySearch(f, num);
                f[index] = num;
            }
        }
        return f.length;
    }

    const binarySearch = (f, target) => {
        let low = 0, high = f.length - 1;
        while (low < high) {
            const mid = Math.floor((high - low) / 2) + low;
            if (f[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    };
    ```

    #### 其他：
    1. 知道是动态规划，完全遍历的问题，但是不知道怎么敲代码

### <div id="2021-3-8">2021.3.8 妇女节（^.^)</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

#### 题目理解：
```
/**
* 动态规划 ？
* 滑动窗口 ？
* 毫无头绪 TT
* 对上周知识点的考察 ？？
*/
```

#### 解决办法：
1. 官方题解 - 动态规划
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minCut = function(s) {
    const n = s.length;
    const g = new Array(n).fill(0).map(() => new Array(n).fill(true));

    for (let i = n - 1; i >= 0; --i) {
        for (let j = i + 1; j < n; ++j) {
            g[i][j] = s[i] == s[j] && g[i + 1][j - 1];
        }
    }

    const f = new Array(n).fill(Number.MAX_SAFE_INTEGER);
    for (let i = 0; i < n; ++i) {
        if (g[0][i]) {
            f[i] = 0;
        } else {
            for (let j = 0; j < i; ++j) {
                if (g[j + 1][i]) {
                    f[i] = Math.min(f[i], f[j] + 1);
                }
            }
        }
    }

    return f[n - 1];
};
```

#### 其他：
1. 毫无头绪，一拿到动态规划(所有情况遍历)就卡壳了
2. 脑子一片浆糊，先cv一下


### <div id="2021-3-9">2021.3.9</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

#### 题目理解：
```
/**
* 递归删除
*/
```

#### 解决办法：
1. 直接递归
    ```javascript
    /**
    * @param {string} S
    * @return {string}
    */
    var removeDuplicates = function(S) {
        let res = S.split('')
        let flag = true
        for (let i = 0; i < res.length - 1; i++) {
            if (res[i] === res[i + 1]) {
                flag = false
                res.splice(i + 1, 1)
                res.splice(i, 1)
            }
        }
        if (!flag) return removeDuplicates(res.join(''))
        return res.join('')
    };
    ```

2. 官方题解 - 栈
    ```javascript
    var removeDuplicates = function(S) {
        const stk = [];
        for (const ch of S) {
            if (stk.length && stk[stk.length - 1] === ch) {
                stk.pop();
            } else {
                stk.push(ch);
            }
        }
        return stk.join('');
    };
    ```

3. 其他解法[->](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/cong-30-dao-100wu-chong-shi-xian-jie-jue-vkah/)

#### 其他：
1. 可以稍微动下脑子，用用数据结构知识。

### <div id="2021-3-10">2021.3.10 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/basic-calculator/)

#### 题目理解：
```
/**
* 栈 ？  但是不会写
*/
```

#### 解决办法：
1. 官方题解 - [括号展开 + 栈]
    ```javascript
    var caculate = function (s) {
        // console.info(s)
        const ops = [1];  // 操作栈，标识是否有操作
        let sign = 1;  // 为当前 计算的值

        let ret = 0;
        const n = s.length;
        let i = 0;

        // console.info(n)

        while (i < n) {
            // console.info('i = ', i)
            // console.info('s[i] = ', s[i])
            // console.info('sign = ', sign)
            // console.info('ops = ', ops)
            if (s[i] === ' ') {
                // console.info('skip ...')
                i++;
            } else if (s[i] === '+') {
                // console.info('拿到新 ...')
                sign = ops[ops.length - 1]; // 拿到最新信息
                i++;
            } else if (s[i] === '-') {
                // console.info('拿到新 ...')
                sign = -ops[ops.length - 1]; // 拿到最新信息
                i++;
            } else if (s[i] === '(') {
                // console.info('入栈...')
                ops.push(sign); // 入栈
                i++;
            } else if (s[i] === ')') {
                // console.info('出栈...')
                ops.pop(); // 出栈
                i++;
            } else {
                // 是数字就计算...
                // console.info('计算...')
                let num = 0;
                while (i < n && !(isNaN(Number(s[i]))) && s[i] !== ' ') {
                    num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt();
                    // console.info('s[i]: ', s[i])
                    // console.info('num: ', num)
                    i++;
                }
                // console.info('sign: ', sign)
                // console.info('num: ', num)
                // console.info('ret: ', ret)
                ret += sign * num;
                // console.info('得到：', ret)
            }
        }
        return ret;
    }

    // var result = caculate(" (2 + (2 - 1)) - 10")
    // console.log("result = ", result)
    ```
#### 其他：
1. 栈 实现

### <div id="2021-3-11">2021.3.11 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/basic-calculator-ii/)

#### 题目理解：
```
/**
* 栈 
*/
```

#### 解决办法：
1. 官方题解 - [栈]
    ```javascript
    var calculate = function(s) {
        s = s.trim();
        const stack = new Array();
        let preSign = '+';
        let num = 0;
        const n = s.length;
        for (let i = 0; i < n; ++i) {
            if (!isNaN(Number(s[i])) && s[i] !== ' ') {
                num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt();
            }
            if (isNaN(Number(s[i])) || i === n - 1) {
                switch (preSign) {
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    default:
                        stack.push(stack.pop() / num | 0);
                }   
                preSign = s[i];
                num = 0;
            }
        }
        let ans = 0;
        while (stack.length) {
            ans += stack.pop();
        }
        return ans;
    }
    ```

2. 自己的解法
    ```javascript
    /**
    * @param {string} s
    * @return {number}
    **/
    var calculate = function(s) {
        /**
        * 先乘除后加减
        * + - 的数先压入栈中
        * x / 与栈顶元素进行计算
        */
        let arr = []
        let res = 0
        let curOpt = 1 // 1:+,2:-,3:*,4:/
        for (let i = 0; i < s.length; i++) {
            switch(s[i]) {
                case ' ': break
                case '+':
                    curOpt = 1
                    break
                case '-':
                    curOpt = 2
                    break
                case '*':
                    curOpt = 3
                    break
                case '/':
                    curOpt = 4
                    break
                default:
                    let num = 0
                    while(i < s.length && !(isNaN(Number(s[i]))) && s[i] !== ' ') {
                        num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt()
                        i++
                    }
                    i -= 1
                    if (curOpt === 2) {
                        arr.push(-num)    
                    } else if (curOpt === 3) {
                        arr[arr.length - 1] = arr[arr.length - 1] * num
                    } else if (curOpt === 4) {
                        arr[arr.length - 1] = parseInt(arr[arr.length - 1] / num)
                    } else {
                        arr.push(num)
                    }
                    break
            }
        }
        for (let i = 0; i < arr.length; i++) {
            res += arr[i]
        }
        return res
    };
    ```

#### 其他：
1. 搞懂了昨天的就知道今天的怎么搞了

### <div id="2021-3-12">2021.3.12 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

#### 题目理解：
```
/**
* 没看懂题目 
*/
```

#### 解决办法：
1. 官方题解 - [栈]
    ```javascript
    var isValidSerialization = function(preorder) {
        const n = preorder.length;
        let i = 0;
        const stack = [1];
        while (i < n) {
            if (!stack.length) {
                return false;
            }
            if (preorder[i] === ',') {
                ++i;
            } else if (preorder[i] === '#') {
                stack[stack.length - 1]--;
                if (stack[stack.length - 1] === 0) {
                    stack.pop();
                } 
                ++i;
            } else {
                // 读一个数字
                while (i < n && preorder[i] !== ',') {
                    ++i;
                }
                stack[stack.length - 1]--;
                if (stack[stack.length - 1] === 0) {
                    stack.pop();
                }
                stack.push(2);
            }
        }
        return stack.length === 0;
    };
    ```

2. 官方题解 - [计数]
    ```javascript
    var isValidSerialization = function(preorder) {
        const n = preorder.length;
        let i = 0;
        let slots = 1;
        while (i < n) {
            if (slots === 0) {
                return false;
            }
            if (preorder[i] === ',') {
                ++i;
            } else if (preorder[i] === '#') {
                --slots;
                ++i;
            } else {
                // 读一个数字
                while (i < n && preorder[i] !== ',') {
                    ++i;
                }
                ++slots; // slots = slots - 1 + 2
            }
        }
        return slots === 0;
    };
    ```

#### 其他：
1. 无效题目，不知道干啥，脑子疼

### <div id="2021-3-15">2021.3.15</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/spiral-matrix/)

#### 题目理解：
```
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    /**
     * 搞清方向即可： 顺时针旋转
     */
    var arr = []
    var i = 0, j = 0
    var m = matrix.length - 1, n = matrix[0].length - 1
    var layer = 0
    while(arr.length < matrix[0].length * matrix.length) {
        arr.push(matrix[i][j])
        /**
         * 怎么转？
         * 转折条件： (layer 随变化改变)
         *    第一个弯：i === layer, j === n - layer
         *      递进: j++
         *    第二个弯：j === n - layer, i === m - layer
         *      递进: i++
         *    第三个弯：j === layer, i === m - layer
         *      递进: j--
         *      完了之后：layer + 1
         *    第四个弯：j === layer, i === layer
         *      递进：i--
         */
        }

    }
    return arr
};
```

#### 解决办法：
1. 官方题解 - [模拟]
    ```javascript
    var spiralOrder = function(matrix) {
        if (!matrix.length || !matrix[0].length) {
            return [];
        }
        const rows = matrix.length, columns = matrix[0].length;
        const visited = new Array(rows).fill(0).map(() => new Array(columns).fill(false));
        const total = rows * columns;
        const order = new Array(total).fill(0);

        let directionIndex = 0, row = 0, column = 0;
        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        for (let i = 0; i < total; i++) { 
            order[i] = matrix[row][column];
            visited[row][column] = true;
            const nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (!(0 <= nextRow && nextRow < rows && 0 <= nextColumn && nextColumn < columns && !(visited[nextRow][nextColumn]))) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    };
    ```

2. 官方题解 - [按层模拟]
    ```javascript
    var spiralOrder = function(matrix) {
        if (!matrix.length || !matrix[0].length) {
            return [];
        }

        const rows = matrix.length, columns = matrix[0].length;
        const order = [];
        let left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (let column = left; column <= right; column++) {
                order.push(matrix[top][column]);
            }
            for (let row = top + 1; row <= bottom; row++) {
                order.push(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (let column = right - 1; column > left; column--) {
                    order.push(matrix[bottom][column]);
                }
                for (let row = bottom; row > top; row--) {
                    order.push(matrix[row][left]);
                }
            }
            [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
        }
        return order;
    };
    ```

#### 其他：
1. 额，只想到一层 for 循环，脑子瓦特了

### <div id="2021-3-16">2021.3.16</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/spiral-matrix-ii/)
#### 题目理解：
```javascript
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    /**
     * 昨天的升级版
     */
    var res = new Array(n).fill(0).map(() => new Array(n).fill(0));
    var num = 1
    const rows = n, columns = n;
    let left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left <= right && top <= bottom) {
        for (let column = left; column <= right; column++) {
            res[top][column] = num++;
        }
        for (let row = top + 1; row <= bottom; row++) {
            res[row][right] = num++;
        }
        if (left < right && top < bottom) {
            for (let column = right - 1; column > left; column--) {
                res[bottom][column] = num++;
            }
            for (let row = bottom; row > top; row--) {
                res[row][left] = num++;
            }
        }
        [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
    }
    return res
};
```
#### 解决办法：
1. 官方题解 - [模拟]
    ```javascript
    var generateMatrix = function(n) {
        const maxNum = n * n;
        let curNum = 1;
        const matrix = new Array(n).fill(0).map(() => new Array(n).fill(0));
        let row = 0, column = 0;
        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // 右下左上
        let directionIndex = 0;
        while (curNum <= maxNum) {
            matrix[row][column] = curNum;
            curNum++;
            const nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= n || nextColumn < 0 || nextColumn >= n || matrix[nextRow][nextColumn] !== 0) {
                directionIndex = (directionIndex + 1) % 4; // 顺时针旋转至下一个方向
            }
            row = row + directions[directionIndex][0];
            column = column + directions[directionIndex][1];
        }
        return matrix;
    };
    ```

2. 官方题解 - [按层模拟]
    ```javascript
    var generateMatrix = function(n) {
        let num = 1;
        const matrix = new Array(n).fill(0).map(() => new Array(n).fill(0));
        let left = 0, right = n - 1, top = 0, bottom = n - 1;
        while (left <= right && top <= bottom) {
            for (let column = left; column <= right; column++) {
                matrix[top][column] = num;
                num++;
            }
            for (let row = top + 1; row <= bottom; row++) {
                matrix[row][right] = num;
                num++;
            }
            if (left < right && top < bottom) {
                for (let column = right - 1; column > left; column--) {
                    matrix[bottom][column] = num;
                    num++;
                }
                for (let row = bottom; row > top; row--) {
                    matrix[row][left] = num;
                    num++;
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return matrix;
    };
    ```
#### 其他：
1. 基础....

### <div id="2021-3-17">2021.3.17</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/distinct-subsequences/)
#### 题目理解：
```javascript
/**
 * 动态规划，全遍历
*/
```
#### 解决办法：
1. 官方解法 - 动态规划
    ```javascript
    var numDistinct = function(s, t) {
        /**
         * 动态规划，全遍历
        */
        const m = s.length, n = t.length
        if (m < n) {
            return 0
        }
        const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0))
        for (let i = 0; i <= m; i++) {
            dp[i][n] = 1
        }
        for (let i = m - 1; i >= 0; i--) {
            for (let j = n - 1; j >= 0; j--) {
                if (s[i] == t[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]
                } else {
                    dp[i][j] = dp[i + 1][j]
                }
            }
        }
        return dp[0][0]
    };
    ```
#### 其他：
1. 又是动态规划，据说有什么状态转移方程

### <div id="2021-3-18">2021.3.18</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
#### 题目理解：
```javascript
/**
 * 反转链表
*/
```
#### 解决办法：
1. 直接反转
    ```javascript
    /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
    /**
    * @param {ListNode} head
    * @param {number} left
    * @param {number} right
    * @return {ListNode}
    */
    var reverseBetween = function(head, left, right) {
        /**
        * 遍历一遍，找到开始反转节点，一个个开始反转，
        */
        if (left === right) return head
        var cur = 1
        var curP = head
        var preP = head
        var start = head
        while(cur <= right) {
            if (right === cur) {
                if (!start.next) {
                    break
                }
                if (!start.next.next) {
                    start.next = null
                } else {
                    if (left === 1) {
                        start.next = curP.next
                        curP.next = preP
                    } else {
                        start.next.next = curP.next
                        start.next = curP
                    }
                }
                curP.next = preP
                if (left === 1) {
                    head = curP
                }
                break
            }
            if (left > cur) {
                cur++
                preP = curP
                curP = curP.next
            } else if (left === cur) {
                start = preP
                cur++
                preP = curP
                curP = curP.next
            } else if (cur > left) {
                var tmp = curP.next
                curP.next = preP
                preP = curP
                curP = tmp
                cur++ 
            }
        }    
        return head
    };
    ```

2. 官方题解 - 穿针引线
    ```javascript
    var reverseBetween = function(head, left, right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        const dummyNode = new ListNode(-1);
        dummyNode.next = head;

        let pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (let i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        let rightNode = pre;
        for (let i = 0; i < right - left + 1; i++) {
            rightNode = rightNode.next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        let leftNode = pre.next;
        let curr = rightNode.next;

        // 注意：切断链接
        pre.next = null;
        rightNode.next = null;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre.next = rightNode;
        leftNode.next = curr;
        return dummyNode.next;
    };

    const reverseLinkedList = (head) => {
        let pre = null;
        let cur = head;

        while (cur) {
            const next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
    ```
#### 其他：
无

### <div id="2021-3-19">2021.3.19</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/design-parking-system)
#### 题目理解：
```javascript
/**
 * 简单构造一个类
*/
```
#### 解决办法：
1. 直接用 Array 或者 Set
    ```javascript
    /**
    * @param {number} big
    * @param {number} medium
    * @param {number} small
    */
    var ParkingSystem = function(big, medium, small) {
        this.parkings = [big, medium, small]
    };

    /** 
    * @param {number} carType
    * @return {boolean}
    */
    ParkingSystem.prototype.addCar = function(carType) {
        if (this.parkings[Number(carType) - 1] > 0) {
            this.parkings[Number(carType) - 1]--
            return true
        } else {
            return false
        }
    };
    ```
2. 官方题解 - 模拟
    ```javascript
    var ParkingSystem = function(big, medium, small) {
        this.big = big;
        this.medium = medium;
        this.small = small;
    };

    ParkingSystem.prototype.addCar = function(carType) {
        if (carType === 1) {
            if (this.big > 0) {
                this.big--;
                return true;
            }
        } else if (carType === 2) {
            if (this.medium > 0) {
                this.medium--;
                return true;
            }
        } else if (carType === 3) {
            if (this.small > 0) {
                this.small--;
                return true;
            }
        }
        return false;
    };
    ```
#### 其他：
无

### <div id="2021-3-22">2021.3.22</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/number-of-1-bits/)
#### 题目理解：
```javascript
/**
 * >> 移位
 * & 同1为1
 * | 同0为0
 */
```
#### 解决办法：
1. 官方解答
    ```javascript
    /**
     * @param {number} n - a positive integer
     * @return {number}
     */
    var hammingWeight = function(n) {
        /**
        * >> 移位
        * & 同1为1
        * | 同0为0
        */
        var ret = 0;
        for (var i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    };
    ```
#### 其他：
无

### <div id="2021-3-23">2021.3.23</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)
#### 题目理解：
```javascript
/**
 *  栈
 */
```
#### 解决办法：
1. 官方解答 - [深度优先搜索DFS]
    ```javascript
    var NestedIterator = function(nestedList) {
        vals = [];
        const dfs = (nestedList) => {
            for (const nest of nestedList) {
                if (nest.isInteger()) {
                    vals.push(nest.getInteger());
                } else {
                    dfs(nest.getList());
                }
            }
        }
        dfs(nestedList);
    };

    NestedIterator.prototype.hasNext = function() {
        return vals.length > 0;
    };

    NestedIterator.prototype.next = function() {
        const val = vals[0];
        vals = vals.slice(1);
        return val;
    };
    ```
2. 官方解答 - [栈]
    ```javascript
    var NestedIterator = function(nestedList) {
        this.stack = nestedList;
    };

    NestedIterator.prototype.hasNext = function() {
        while (this.stack.length !== 0) {
            if (this.stack[0].isInteger()) {
                return true;
            } else {
                let cur = this.stack[0].getList();
                this.stack.shift();
                this.stack.unshift(...cur);
            }
        }
    };

    NestedIterator.prototype.next = function() {
        return this.stack.shift().getInteger();
    };
    ```
#### 其他：
1. 递归或者栈，但是递归不太对，不太符合迭代器
2. 合理利用题目所给的辅助函数

### <div id="2021-3-24">2021.3.24</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/132-pattern/)
#### 题目理解：
```javascript
/**
 *  检查 132 模式即可
 * 1. 找到除头尾最大值， 然后比较有没有 ai < aj 
 *    不能覆盖所有情况
 * 2. 全遍历  超时
 */
```
#### 解决办法：
1. 官方解答 - [枚举1]
    ```javascript
    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var find132pattern = function(nums) {
        const n = nums.length;
        const candidate_k = [nums[n - 1]];
        let max_k = -Number.MAX_SAFE_INTEGER;

        for (let i = n - 2; i >= 0; --i) {
            if (nums[i] < max_k) {
                return true;
            }
            while (candidate_k.length && nums[i] > candidate_k[candidate_k.length - 1]) {
                max_k = candidate_k[candidate_k.length - 1];
                candidate_k.pop();
            }
            if (nums[i] > max_k) {
                candidate_k.push(nums[i]);
            }
        }
        return false;
    };
    ```
2. 官方解答 - [枚举3,比较容易想到]
    ```C++
    class Solution {
    public:
        bool find132pattern(vector<int>& nums) {
            int n = nums.size();
            if (n < 3) {
                return false;
            }

            // 左侧最小值
            int left_min = nums[0];
            // 右侧所有元素
            multiset<int> right_all;

            for (int k = 2; k < n; ++k) {
                right_all.insert(nums[k]);
            }

            for (int j = 1; j < n - 1; ++j) {
                if (left_min < nums[j]) {
                    auto it = right_all.upper_bound(left_min);
                    if (it != right_all.end() && *it < nums[j]) {
                        return true;
                    }
                }
                left_min = min(left_min, nums[j]);
                right_all.erase(right_all.find(nums[j + 1]));
            }

            return false;
        }
    };
    ```
3. 官方解答 - [枚举2,难度比较大]
    ```javascript
    var find132pattern = function(nums) {
        const n = nums.length;
        const candidateI = [nums[0]], candidateJ = [nums[0]];

        for (let k = 1; k < n; ++k) {
            const idxI = binarySearchFirst(candidateI, nums[k]);
            const idxJ = binarySearchLast(candidateJ, nums[k]);
            if (idxI >= 0 && idxJ >= 0) {
                if (idxI <= idxJ) {
                    return true;
                }
            }
            
            if (nums[k] < candidateI[candidateI.length - 1]) {
                candidateI.push(nums[k]);
                candidateJ.push(nums[k]);
            } else if (nums[k] > candidateJ[candidateJ.length - 1]) {
                const lastI = candidateI[candidateI.length - 1];
                while (candidateJ.length && nums[k] > candidateJ[candidateJ.length - 1]) {
                    candidateI.pop();
                    candidateJ.pop();
                }
                candidateI.push(lastI);
                candidateJ.push(nums[k]);
            }
        }

        return false;
    };

    const binarySearchFirst = (candidate, target) => {
        let low = 0, high = candidate.length - 1;
        if (candidate[high] >= target) {
            return -1;
        }
        while (low < high) {
            const mid = Math.floor((high - low) / 2) + low;
            const num = candidate[mid];
            if (num >= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    const binarySearchLast = (candidate, target) => {
        let low = 0, high = candidate.length - 1;
        if (candidate[low] <= target) {
            return -1;
        }
        while (low < high) {
            const mid = Math.floor((high - low + 1) / 2) + low;
            const num = candidate[mid];
            if (num <= target) {
                high = mid - 1;
            } else {
                low = mid;
            }
        }
        return low;
    }
    ```
#### 其他：
1. 其实举例3已经想到了，但是没有进行枚举，直接想到三个 for 循环
2. 单调栈，二分查找

### <div id="2021-3-25">2021.3.25</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
#### 题目理解：
```javascript
/**
 * 直接删除，添加一个前置头
 */
```
#### 解决办法：
1. 直接解答 - [链表删除]
    ```javascript
    /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
    /**
    * @param {ListNode} head
    * @return {ListNode}
    */
    var deleteDuplicates = function(head) {
        if (head === null || head.next === null) return head
        let cur = head.next
        let pre = head
        let ppre = new ListNode(0, head)
        let h = ppre
        while(cur) {
            if (pre.val === cur.val) {
                let cpre = cur
                while(cur) {
                    if (pre.val === cur.val) {
                        cpre = cur
                        cur = cur.next
                    } else {
                        break
                    }
                }
                cur = cpre
                ppre.next = cur.next
                pre = ppre.next
                if (pre) {
                    cur = pre.next
                } else {
                    break
                }
            } else {
                ppre = pre
                pre = cur
                cur = cur.next
            }
        }
        return h.next
    };
    ```
2. 官方解答 - [一次遍历]
    ```javascript
    var deleteDuplicates = function(head) {
        if (!head) {
            return head;
        }
        const dummy = new ListNode(0, head);
        let cur = dummy;
        while (cur.next && cur.next.next) {
            if (cur.next.val === cur.next.next.val) {
                const x = cur.next.val;
                while (cur.next && cur.next.val === x) {
                    cur.next = cur.next.next;
                } 
            } else {
                cur = cur.next;
            }
        }
        return dummy.next;
    };
    ```
#### 其他：
1. 写的不够简洁

### <div id="2021-3-26">2021.3.26</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
#### 题目理解：
```javascript
/**
 * 比昨天简单
 */
```
#### 解决办法：
1. 直接解答 - [链表删除]
    ```javascript
    /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
    /**
    * @param {ListNode} head
    * @return {ListNode}
    */
    var deleteDuplicates = function(head) {
        /**
        * 比昨天还简单
        */
        if (head  === null || head.next === null) return head
        let cur = head.next, pre = head
        while(cur) {
            if (cur.val === pre.val) {
                pre.next = cur.next
                cur = pre.next
            } else {
                pre = cur
                cur = cur.next
            }
        }
        return head
    };
    ```
2. 官方解答 - [一次遍历]
    ```javascript
    var deleteDuplicates = function(head) {
        if (!head) {
            return head;
        }

        let cur = head;
        while (cur.next) {
            if (cur.val === cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;
    }; 
    ```
#### 其他：
无

### <div id="2021-3-29">2021.3.29</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/reverse-bits/)
#### 题目理解：
```javascript
/**
 * 移位
 */
```
#### 解决办法：
1. 官方解答 - [逐位颠倒]
    ```javascript
    var reverseBits = function(n) {
        let rev = 0;
        for (let i = 0; i < 32 && n > 0; ++i) {
            rev |= (n & 1) << (31 - i);
            n >>>= 1;
        }
        return rev >>> 0;
    };
    ```
2. 官方解答 - [位运算分治]
    ```javascript
    var reverseBits = function(n) {
        const M1 = 0x55555555; // 01010101010101010101010101010101
        const M2 = 0x33333333; // 00110011001100110011001100110011
        const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
        const M8 = 0x00ff00ff; // 00000000111111110000000011111111

        n = n >>> 1 & M1 | (n & M1) << 1;
        n = n >>> 2 & M2 | (n & M2) << 2;
        n = n >>> 4 & M4 | (n & M4) << 4;
        n = n >>> 8 & M8 | (n & M8) << 8;
        return (n >>> 16 | n << 16) >>> 0;
    };
    ```
#### 其他：
1. 脑子瓦特了，最近

### <div id="2021-3-30">2021.3.30</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/search-a-2d-matrix/)
#### 题目理解：
```javascript
/**
 * 二分查找
 */
```
#### 解决办法：
1. 自己解答 - [行数减 / 2, 行数递加，列数递加]
    ```javascript
    var searchMatrix = function(matrix, target) {
        /**
         * 二分查找？
        */
        var row = matrix.length - 1, col = matrix[0].length - 1
        var res = false
        if (row < 0 || col < 0) return false
        if (matrix[0][0] > target || matrix[row][col] < target) return false
        while (row >= 0) {
            if ((matrix[row][0] <= target && matrix[row][col] >= target) ||
                (matrix[row][0] <= target && matrix[row + 1][0] > target)) {
                for (let j = col; j >= 0; j--) {
                    if (matrix[row][j] === target) {
                        return true
                    }
                }
                break
            } else if (matrix[row][0] > target) {
                row = parseInt((0 + row) / 2)
            } else {
                row++
            }
        }
        return res
    };
    ```
2. 官方解答 - [两次二分查找]
    ```javascript
    var searchMatrix = function(matrix, target) {
        const rowIndex = binarySearchFirstColumn(matrix, target);
        if (rowIndex < 0) {
            return false;
        }
        return binarySearchRow(matrix[rowIndex], target);
    };

    const binarySearchFirstColumn = (matrix, target) => {
        let low = -1, high = matrix.length - 1;
        while (low < high) {
            const mid = Math.floor((high - low + 1) / 2) + low;
            if (matrix[mid][0] <= target) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    const binarySearchRow = (row, target) => {
        let low = 0, high = row.length - 1;
        while (low <= high) {
            const mid = Math.floor((high - low) / 2) + low;
            if (row[mid] == target) {
                return true;
            } else if (row[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return false;
    }
    ```
3. 官方解答 - [一次二分查找]
    ```javascript
    var searchMatrix = function(matrix, target) {
        const m = matrix.length, n = matrix[0].length;
        let low = 0, high = m * n - 1;
        while (low <= high) {
            const mid = Math.floor((high - low) / 2) + low;
            const x = matrix[Math.floor(mid / n)][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    };
    ```
#### 其他：
1. 自己没想好二分查找，

### <div id="2021-3-31">2021.3.31</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/subsets-ii/)
#### 题目理解：
```javascript
/**
 * 排列组合
 */
```
#### 解决办法：
1. 官方解答 - [迭代法实现子集枚举]
    ```javascript
    var subsetsWithDup = function(nums) {
        nums.sort((a, b) => a - b);
        let t = [], ans = [];
        const n = nums.length;
        for (let mask = 0; mask < (1 << n); ++mask) {
            t = [];
            let flag = true;
            for (let i = 0; i < n; ++i) {
                if ((mask & (1 << i)) != 0) {
                    if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {
                        flag = false;
                        break;
                    }
                    t.push(nums[i]);
                }
            }
            if (flag) {
                ans.push(t.slice());
            }
        }
        return ans;
    };
    ```
2. 官方解答 - [递归法实现子集枚举]
    ```javascript
    var subsetsWithDup = function(nums) {
        nums.sort((a, b) => a - b);
        let t = [], ans = [];
        const dfs = (choosePre, cur, nums) => {
            if (cur === nums.length) {
                ans.push(t.slice());
                return;
            }
            dfs(false, cur + 1, nums);
            if (!choosePre && cur > 0 && nums[cur - 1] === nums[cur]) {
                return;
            }
            t.push(nums[cur]);
            dfs(true, cur + 1, nums);
            t = t.slice(0, t.length - 1);
        }
        dfs(false, 0, nums);
        return ans;
    };
    ```
#### 其他：
1. 子集枚举

### <div id="2021-4-1">2021.4.1</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/clumsy-factorial/)
#### 题目理解：
```javascript
/**
 * 先乘除后加减
 */
```
#### 解决办法：
1. 直接解答 - [先乘除后加减]
    ```javascript
    /**
     * @param {number} N
    * @return {number}
    */
    var clumsy = function(N) {
        /**
        * 先乘除后加减
        */
        var res = 0
        var i = N
        var opt = 0
        var tmp = i--
        while(i > 0) {
            switch(opt) {
                case 0:
                    tmp *= i
                    break
                case 1:
                    tmp /= i
                    break
                case 2:
                    tmp = parseInt(tmp) + i
                    res += tmp
                    break
                case 3:
                    tmp = -1 * i
                    opt = -1
                    break
            }
            opt += 1
            i -= 1
        }
        if (opt !== 3) res += tmp
        return res
    };
    ```
2. 官方解答 - [使用栈模拟]
    ```javascript
    var clumsy = function(N) {
        const stack = [N--];

        let index = 0; // 用于控制乘、除、加、减
        while (N > 0) {
            if (index % 4 == 0) {
                stack.push(stack.pop() * N);
            } else if (index % 4 == 1) {
                const cur = stack.pop();
                stack.push(cur > 0 ? Math.floor(cur / N) : Math.ceil(cur / N));
            } else if (index % 4 == 2) {
                stack.push(N);
            } else {
                stack.push(-N);
            }
            index++;
            N--;
        }

        // 把栈中所有的数字依次弹出求和
        let sum = 0;
        stack.forEach((element) => {
            sum += element;
        })
        return sum;
    };
    ```
3. 官方解答 - [数学]
    ```javascript
    var clumsy = function(N) {
        if (N === 1) {
            return 1;
        } else if (N === 2) {
            return 2;
        } else if (N === 3) {
            return 6;
        } else if (N === 4) {
            return 7;
        }

        if (N % 4 === 0) {
            return N + 1;
        } else if (N % 4 <= 2) {
            return N + 2;
        } else {
            return N - 1;
        }
    };
    ```
#### 其他：
1. 

### <div id="2021-4-2">2021.4.2</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/volume-of-histogram-lcci/)
#### 题目理解：
```javascript
/**
 * 要放假了~~~，完全没心思！！！
 */
```
#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    /**
     * @param {number[]} height
    * @return {number}
    */
    var trap = function(height) {
        const n = height.length;
        if (n == 0) {
            return 0;
        }

        const leftMax = new Array(n).fill(0);
        leftMax[0] = height[0];
        for (let i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        const rightMax = new Array(n).fill(0);
        rightMax[n - 1] = height[n - 1];
        for (let i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        let ans = 0;
        for (let i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    };
    ```
2. 官方解答 - [单调栈]
    ```javascript
    var trap = function(height) {
        let ans = 0;
        const stack = [];
        const n = height.length;
        for (let i = 0; i < n; ++i) {
            while (stack.length && height[i] > height[stack[stack.length - 1]]) {
                const top = stack.pop();
                if (!stack.length) {
                    break;
                }
                const left = stack[stack.length - 1];
                const currWidth = i - left - 1;
                const currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    };
    ```
3. 官方解答 - [双指针]
    ```javascript
    var trap = function(height) {
        let ans = 0;
        let left = 0, right = height.length - 1;
        let leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    };
    ```
#### 其他：
1. 人生的灵性
 
### <div id="2021-4-8">2021.4.8</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
#### 题目理解：
```javascript
/**
* a. 最小的可能是第一个
* b. 遇到 从大变小的那么那个小数是最小值
*/
```
#### 解决办法：
1. 直接解答 - [直接查找]
    ```javascript
    /**
    * @param {number[]} nums
    * @return {number}
    */
    var findMin = function(nums) {
        /**
        * a. 最小的可能是第一个
        * b. 遇到 从大变小的那么那个小数是最小值
        */
        let res = nums[0]
        for (let i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i+1]) {
                res = nums[i+1]
                break
            }
        }
        return res
    };
    ```
2. 官方解答 - [二分查找]
    ```c++
    class Solution {
    public:
        int findMin(vector<int>& nums) {
            int low = 0;
            int high = nums.size() - 1;
            while (low < high) {
                int pivot = low + (high - low) / 2;
                if (nums[pivot] < nums[high]) {
                    high = pivot;
                }
                else {
                    low = pivot + 1;
                }
            }
            return nums[low];
        }
    };
    ```
#### 其他：
1. 二分查找想到了，但是不知道这里怎么用

### <div id="2021-4-9">2021.4.9</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
#### 题目理解：
```javascript
/**
* a. 最小的可能是第一个
* b. 遇到 从大变小的那么那个小数是最小值
*/
```
#### 解决办法：
1. 直接解答 - [直接查找]
    ```javascript
    /**
    * @param {number[]} nums
    * @return {number}
    */
    var findMin = function(nums) {
        /**
        * a. 最小的可能是第一个
        * b. 遇到 从大变小的那么那个小数是最小值
        */
        let res = nums[0]
        for (let i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i+1]) {
                res = nums[i+1]
                break
            }
        }
        return res
    };
    ```
2. 官方解答 - [二分查找]
    ```javascript
    var findMin = function(nums) {
        let low = 0
        let high = nums.length - 1
        while(low < high) {
            const pivot = low + Math.floor((high - low) / 2);
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else if (nums[pivot] > nums[high]) {
                low = pivot + 1;
            } else {
                high -= 1;
            }
        }
        return nums[low]
    };
    ```
#### 其他：
1. 与前一道题相似
 
### <div id="2021-4-12">2021.4.12</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/largest-number/)
#### 题目理解：
```javascript
/**
* 全遍历？
* 动态规划 ？
*/
```
#### 解决办法：
1. 官方解答 - [排序]
    ```javascript
    /**
    * @param {number[]} nums
    * @return {string}
    */
    var largestNumber = function(nums) {
        nums.sort((x, y) => {
            let sx = 10, sy = 10;
            while (sx <= x) {
                sx *= 10;
            }
            while (sy <= y) {
                sy *= 10;
            }
            return '' + (sx * y + x) - ('' + (sy * x + y));
        })
        if (nums[0] === 0) {
            return '0';
        }
        return nums.join('');
    };
    ```

#### 其他：
1. 规律还是可信的，不要想太多


### <div id="2021-4-13">2021.4.13</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)
#### 题目理解：
```javascript
/**
 * 遍历: 必不可少
 * 二叉搜索树的特点排序：左中右
 * 所以：算 中 - 左， 右 - 中 ； 比较最小差值即可
 */
```
#### 解决办法：
1. 错误解答 - [遍历了相邻的差值]
    ```javascript
    /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
    /**
    * @param {TreeNode} root
    * @return {number}
    */
    var minDiffInBST = function(root) {
        /**
        * 遍历: 必不可少
        * 二叉搜索树的特点排序：左中右
        * 所以：算 中 - 左， 右 - 中 ； 比较最小差值即可
        */
        return bst(root, Number.MAX_VALUE)
    };

    function bst(root, num) {
        if (!root) return num
        if (root.left) {
            let tmp = root.val - root.left.val
            num = tmp < num ? tmp : num
            let leftNum = bst(root.left, num)
            num = leftNum < num ? leftNum : num
        }
        if (root.right) {
            let tmp = root.right.val - root.val
            num = tmp < num ? tmp : num
            let rightNum = bst(root.right, num)
            num = rightNum < num ? rightNum : num
        }
        return num
    }
    ```

2. 官方解答 - [中序遍历二叉搜索树] 
    ```javascript
    var minDiffInBST = function(root) {
        let ans = Number.MAX_SAFE_INTEGER, pre = -1;
        const dfs = (root) => {
            if (root === null) {
                return;
            }
            dfs(root.left);
            if (pre == -1) {
                pre = root.val;
            } else {
                ans = Math.min(ans, root.val - pre);
                pre = root.val;
            }
            dfs(root.right);
        }
        dfs(root);
        return ans;
    };
    ```
#### 其他：
1. 二叉搜索树的排序来，但是不是左右两个差就可以算出最小差值的。

### <div id="2021-4-14">2021.4.14</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
#### 题目理解：
```javascript
/**
 * 直接根据意思来了，利用数组
 */
```
#### 解决办法：
1. 直接解答 - [数组]
    ```javascript
    /**
    * Initialize your data structure here.
    */
    var Trie = function() {
        this.list = []
    };

    /**
    * Inserts a word into the trie. 
    * @param {string} word
    * @return {void}
    */
    Trie.prototype.insert = function(word) {
        this.list.push(word)
    };

    /**
    * Returns if the word is in the trie. 
    * @param {string} word
    * @return {boolean}
    */
    Trie.prototype.search = function(word) {
        if (this.list.indexOf(word) !== -1) return true
        return false
    };

    /**
    * Returns if there is any word in the trie that starts with the given prefix. 
    * @param {string} prefix
    * @return {boolean}
    */
    Trie.prototype.startsWith = function(prefix) {
        for (let i = 0; i < this.list.length; i++) {
            if (this.list[i].startsWith(prefix)) return true
        }
        return false
    };

    /**
    * Your Trie object will be instantiated and called as such:
    * var obj = new Trie()
    * obj.insert(word)
    * var param_2 = obj.search(word)
    * var param_3 = obj.startsWith(prefix)
    */
    ```

2. 官方解答 - [字典树] 
    ```javascript
    var Trie = function() {
        this.children = {};
    };

    Trie.prototype.insert = function(word) {
        let node = this.children;
        for (const ch of word) {
            if (!node[ch]) {
                node[ch] = {};
            }
            node = node[ch];
        }
        node.isEnd = true;
    };

    Trie.prototype.searchPrefix = function(prefix) {
        let node = this.children;
        for (const ch of prefix) {
            if (!node[ch]) {
                return false;
            }
            node = node[ch];
        }
        return node;
    }

    Trie.prototype.search = function(word) {
        const node = this.searchPrefix(word);
        return node !== undefined && node.isEnd !== undefined;
    };

    Trie.prototype.startsWith = function(prefix) {
        return this.searchPrefix(prefix);
    };
    ```
#### 其他：
1. 没有考虑前缀树的特殊性，题目不是很看得懂，直接根据案例函数的功能来写了

### <div id="2021-4-15">2021.4.15</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/house-robber-ii/)
#### 题目理解：
```javascript
/**
* 奇偶区分：
*   1. 奇数个： 头尾是相邻的，头可加或者尾可加，比较大小
*   2. 偶数个： 间隔加
* 
* k 表示 间隔距离
*/
```
#### 解决办法：
1. 直接解答 - [数组]
    ```javascript
    /**
    * @param {number[]} nums
    * @return {number}
    */
    var rob = function(nums) {
        /**
        * 奇偶区分：
        *   1. 奇数个： 头尾是相邻的，头可加或者尾可加，比较大小
        *   2. 偶数个： 间隔加
        * 
        * k 表示 间隔距离
        */
        let len = nums.length
        let res = [0, 0]
        for (let i = 0; i < len; i++) {
            if (i % 2) {
                res[0] += nums[i]  // 第一间隔
            } else {
                res[1] += nums[i]  // 第二间隔
            }
        }
        if (len > 1 && len % 2 === 1 ) {
            if (nums[0] > nums[len - 1]) {
                res[1] -= nums[len - 1]
            } else {
                res[1] -= nums[0]
            }
        }
        return Math.max(res[0], res[1])
    };
    ```
    不通过案例： [1,3,1,3,100]
    输出：101
    答案：103， k 间隔为 2

2. 官方解答 - [动态规划] 
    ```javascript
    var rob = function(nums) {
        const length = nums.length;
        if (length === 1) {
            return nums[0];
        } else if (length === 2) {
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
    };

    const robRange = (nums, start, end) => {
        let first = nums[start], second = Math.max(nums[start], nums[start + 1]);
        for (let i = start + 2; i <= end; i++) {
            const temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
    ```
#### 其他：
1. 这题原来是动态规划，案例思考只局限在了示例上

### <div id="2021-4-16">2021.4.16 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/scramble-string/)
#### 题目理解：
```javascript
/**
* 递归
* 遍历
* 动态规划
* 题目没怎么看懂
*/
```
#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    var isScramble = function(s1, s2) {
        const length = s1.length;
        memo = new Array(length).fill(0).map(() => new Array(length).fill(0).map(() => new Array(length + 1).fill(0)));
        return dfs(0, 0, length, s1, s2, memo);
    };

    const dfs = function(i1, i2, length, s1, s2, memo) {
        if (memo[i1][i2][length] !== 0) {
            return memo[i1][i2][length] === 1;
        }

        // 判断两个子串是否相等
        if (s1.slice(i1, i1 + length) === s2.slice(i2, i2 + length)) {
            memo[i1][i2][length] = 1;
            return true;
        }

        // 判断是否存在字符 c 在两个子串中出现的次数不同
        if (!checkIfSimilar(i1, i2, length, s1, s2)) {
            memo[i1][i2][length] = -1;
            return false;
        }

        // 枚举分割位置
        for (let i = 1; i < length; ++i) {
            // 不交换的情况
            if (dfs(i1, i2, i, s1, s2, memo) && dfs(i1 + i, i2 + i, length - i, s1, s2, memo)) {
                memo[i1][i2][length] = 1;
                return true;
            }
            // 交换的情况
            if (dfs(i1, i2 + length - i, i, s1, s2, memo) && dfs(i1 + i, i2, length - i, s1, s2, memo)) {
                memo[i1][i2][length] = 1;
                return true;
            }
        }

        memo[i1][i2][length] = -1;
        return false;
    }

    const checkIfSimilar = function(i1, i2, length, s1, s2) {
        const freq = new Map();
        for (let i = i1; i < i1 + length; ++i) {
            const c = s1[i];
            freq.set(c, (freq.get(c) || 0) + 1);
        }
        for (let i = i2; i < i2 + length; ++i) {
            const c = s2[i];
            freq.set(c, (freq.get(c) || 0) - 1);
        }
        for (const value of freq.values()) {
            if (value !== 0) {
                return false;
            }
        }
        return true;
    }
    ```

#### 其他：
1. 无

### <div id="2021-4-19">2021.4.19 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/scramble-string/)
#### 题目理解：
```javascript
/**
* 想到双指针了，
* 没有理清头绪，
* 为了保持数组的顺序的话，还是需要一个个移动。
* 但是重点就是本题无需保持顺序
*/
```
#### 解决办法：
1. 直接解答 - [直接移动]
    ```javascript
    var removeElement = function(nums, val) {
        let len = nums.length
        for (let i = 0; i < nums.length; ) {
            if (val === nums[i]) {
                for (let j = i; j < nums.length; j++) {
                    nums[j] = nums[j+1]
                }
                len -= 1
            } else {
                i += 1
            }
        }
        return len
    }; 
    ```

2. 官方解答 - [双指针]
    ```javascript
    var removeElement = function(nums, val) {
        const n = nums.length;
        let left = 0;
        for (let right = 0; right < n; right++) {
            if (nums[right] !== val) {
                nums[left] = nums[right];
                left++;
            }
        }
        return left;
    };
    ```

3. 官方解答 - [双指针优化]
    ```javascript
    var removeElement = function(nums, val) {
        let left = 0, right = nums.length;
        while (left < right) {
            if (nums[left] === val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    };
    ```

#### 其他：
1. 无

### <div id="2021-4-20">2021.4.20 </div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/implement-strstr/)
#### 题目理解：
```javascript
/**
* 直接 indexOf 函数
*/
```
#### 解决办法：
1. 直接解答 - [indexOf 内置函数]
    ```javascript
    /**
    * @param {string} haystack
    * @param {string} needle
    * @return {number}
    */
    var strStr = function(haystack, needle) {
        return haystack.indexOf(needle)
    };
    ```

2. 官方解答 - [暴力匹配]
    - 前言
        本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、\text{Knuth-Morris-Pratt}Knuth-Morris-Pratt 算法、\text{Boyer-Moore}Boyer-Moore 算法、\text{Sunday}Sunday 算法等，本文将讲解 \text{Knuth-Morris-Pratt}Knuth-Morris-Pratt 算法。

        因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而 \text{strStr}strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 \text{Rabin-Karp}Rabin-Karp 算法）。

    ```javascript
    var strStr = function(haystack, needle) {
        const n = haystack.length, m = needle.length;
        for (let i = 0; i + m <= n; i++) {
            let flag = true;
            for (let j = 0; j < m; j++) {
                if (haystack[i + j] != needle[j]) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    };
    ```

3. 官方解答 - [Knuth-Morris-Pratt 算法]
    ```javascript
    var strStr = function(haystack, needle) {
        const n = haystack.length, m = needle.length;
        if (m === 0) {
            return 0;
        }
        const pi = new Array(m).fill(0);  // 通过 Pi 来标记
        for (let i = 1, j = 0; i < m; i++) {
            while (j > 0 && needle[i] !== needle[j]) {
                j = pi[j - 1];
            }
            if (needle[i] == needle[j]) {
                j++;
            }
            pi[i] = j;
        }
        for (let i = 0, j = 0; i < n; i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = pi[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j === m) {
                return i - m + 1;
            }
        }
        return -1;
    };
    ```

#### 其他：
1. 这个方法有很多，需要花时间仔细看看

### <div id="2021-4-21">2021.4.21</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/decode-ways/)
#### 题目理解：
```javascript
/**
* 递归或者动态规划
* 匹配
* 不会写，但是套路是知道了
*/
```
#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    var numDecodings = function(s) {
        const n = s.length;
        const f = new Array(n + 1).fill(0);
        f[0] = 1;
        for (let i = 1; i <= n; i++) {
            if (s[i - 1] !== '0') {
                f[i] += f[i - 1];
            }
            // 监测向前两个字符是否可以构成一个编码，如果可以那么方法加上
            if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    };
    // 或者
    var numDecodings1 = function(s) {
        const n = s.length;
        // a = f[i-2], b = f[i-1], c = f[i]
        let a = 0, b = 1, c = 0;
        for (let i = 1; i <= n; ++i) {
            c = 0;
            if (s[i - 1] !== '0') {
                c += b;
            }
            if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
                c += a;
            }
            a = b;
            b = c;
        }
        return c;
    };
    ```
2. 其他解答 - [...]
    ```javascript
    ```

#### 其他：
1. ......

### <div id="2021-4-22">2021.4.22</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/submissions/)
#### 题目理解：
```javascript
var maxSumSubmatrix = function(matrix, k) {
    /**
     * 题目都有点看不懂
     * 矩形区域不超过k的和，其中的最大值
     * 用矩形算一遍和值，然后过滤得出结果
     */
    var rect = new Array();
    var res = -1;
    const getMaxLessThanK = function (k, a, b) {
        if (b <= k) {
            return Math.max(a, b);
        }
        return a
    }
    // 从 [0, 0] 开始的矩形  -> 将 [0, 0] 开始改变
    for(var i = 0; i < matrix.length; i++) {
        rect[i] = new Array();
        for(var j = 0; j < matrix[i].length; j++) {
            rect[i][j] = 0; // 0 表示只有一个空的红圈
            if (i === 0 && j === 0) {
                rect[0][0] = matrix[0][0]
            }
            if (i === 0 && j > 0) {
                rect[i][j] = rect[i][j - 1] + matrix[i][j]
            }
            if (j === 0 && i > 0) {
                rect[i][j] = rect[i - 1][j] + matrix[i][j]
            }
            if (j > 0 && i > 0) {
                rect[i][j] = rect[i][j - 1] + rect[i - 1][j] + rect[i][j] - rect[i - 1][j - 1]
            }
            res = getMaxLessThanK(k, res, rect[i][j])
        }
    }
    // 计算从 [x, y] 到 [x1, y1] 的矩形
    for (var i = 0; i < matrix.length; i++) {
        for (var j = 0; j < matrix[i].length; j++) {
            if (i > 0 || j > 0) {
                // 有问题，不能随便产生一个矩形，此矩形靠边
                for (var m = 0; m < i; m++) {
                    var tmp = rect[i][j] - rect[m][j]
                    rect[i][j] = getMaxLessThanK(k, rect[i][j], tmp)
                }
                for (var m = 0; m < j; m++) {
                    var tmp = rect[i][j] - rect[i][m]
                    rect[i][j] = getMaxLessThanK(k, rect[i][j], tmp)
                }
                res = Math.max(res, rect[i][j])
            }
        }   
    }
    return res
};
```
#### 解决办法：
1. 官方解答 - [有序集合]
    ```javascript
    class Solution {
    public:
        int maxSumSubmatrix(vector<vector<int>> &matrix, int k) {
            int ans = INT_MIN;
            int m = matrix.size(), n = matrix[0].size();
            for (int i = 0; i < m; ++i) { // 枚举上边界
                vector<int> sum(n);
                for (int j = i; j < m; ++j) { // 枚举下边界
                    for (int c = 0; c < n; ++c) {
                        sum[c] += matrix[j][c]; // 更新每列的元素和
                    }
                    set<int> sumSet{0};
                    int s = 0;
                    for (int v : sum) {
                        s += v;
                        auto lb = sumSet.lower_bound(s - k);
                        if (lb != sumSet.end()) {
                            ans = max(ans, s - *lb);
                        }
                        sumSet.insert(s);
                    }
                }
            }
            return ans;
        }
    };
    ```
#### 其他：
1. ......思路有问题，没有理清，需要将4层for改造，但是没想出来

### <div id="2021-4-23">2021.4.23 读书日（==)</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/largest-divisible-subset/)
#### 题目理解：
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var largestDivisibleSubset = function(nums) {
    var res = []
    nums.sort((a, b) => a - b)

    /**
     * 有两个组成一个集合，那么就可以是一个新的
     */



    return res
};
```
#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    var largestDivisibleSubset = function(nums) {
        const len = nums.length;
        nums.sort((a, b) => a - b);

        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
        const dp = new Array(len).fill(1);
        let maxSize = 1;
        let maxVal = dp[0];
        for (let i = 1; i < len; i++) {
            for (let j = 0; j < i; j++) {
                // 题目中说「没有重复元素」很重要
                if (nums[i] % nums[j] === 0) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            if (dp[i] > maxSize) {
                maxSize = dp[i];
                maxVal = nums[i];
            }
        }

        // 第 2 步：倒推获得最大子集
        const res = [];
        if (maxSize === 1) {
            res.push(nums[0]);
            return res;
        }
        
        for (let i = len - 1; i >= 0 && maxSize > 0; i--) {
            if (dp[i] === maxSize && maxVal % nums[i] === 0) {
                res.push(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return res;
    };
    ```
#### 其他：
1. TT 不会，可能想到了，但是动态规划一直没摸清套路，不会写

### <div id="2021-4-25">2021.4.25</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/increasing-order-search-tree/)
#### 题目理解：
```javascript
/**
* 递归，这我还真想不到，只有经历过才能知道套路
*/
```
#### 解决办法：
1. 官方解答 - [在中序遍历的过程中改变节点指向]
    ```javascript
    var increasingBST = function(root) {
        const dummyNode = new TreeNode(-1);
        let resNode = dummyNode;
        const inorder = (node) => {
            if (!node) {
                return;
            }
            inorder(node.left);
            resNode.right = node;
            node.left = null;
            resNode = node;

            inorder(node.right);
        }
        inorder(root);
        return dummyNode.right;
    };
    ```

2. 官方解答 - [中序遍历之后生成新的树]
    ```javascript
    var increasingBST = function(root) {
        const res = [];
        inorder(root, res);  // 遍历出来

        const dummyNode = new TreeNode(-1);
        let currNode = dummyNode;  // 生成新树
        for (const value of res) {
            currNode.right = new TreeNode(value);
            currNode = currNode.right;
        }
        return dummyNode.right;
    };

    const inorder = (node, res) => {
        if (!node) {
            return;
        }
        inorder(node.left, res);
        res.push(node.val);
        inorder(node.right, res);
    }
    ```
#### 其他：
1.  数的遍历和递归算法


### <div id="2021-4-26">2021.4.26</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)
#### 题目理解：
```javascript
/**
 * @param {number[]} weights
 * @param {number} D
 * @return {number}
 */
var shipWithinDays = function(weights, D) {
    /**
     * 对 weights 排序的 进行 D-1 次 分割, 
     * 计算出 使分割后的每个组的和 的 最大值 中的 最小值
     */
    var res = []
    // n 个元素，分为 m 个堆，种类

    // 


    return res
};
```
#### 解决办法：
1. 官方解答 - [二分查找转化为判定问题]
    ```javascript
    var shipWithinDays = function(weights, D) {
        // 确定二分查找左右边界
        let left = Math.max(...weights), right = weights.reduce((a, b) => a + b);
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            //  need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            let need = 1, cur = 0;
            for (const weight of weights) {
                if (cur + weight > mid) {
                    need++;
                    cur = 0;
                } 
                cur += weight;
            }

            if (need <= D) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };
    ```

#### 其他：
1.  想不到


### <div id="2021-4-27">2021.4.27</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/range-sum-of-bst/)
#### 题目理解：
```javascript
/**
 * 搜索树
 *  the left < the root < the right
 * a. 根据搜索树特点进行合理遍历然后求和
 * b. 直接遍历，然后看范围求和
 */
```
#### 解决办法：
1. 自己解答 - [遍历]
    ```javascript
    /**
     * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
    /**
    * @param {TreeNode} root
    * @param {number} low
    * @param {number} high
    * @return {number}
    */
    var rangeSumBST = function(root, low, high) {
        /**
        * 搜索树
        *  the left < the root < the right
        * a. 根据搜索树特点进行合理遍历然后求和
        * b. 直接遍历，然后看范围求和
        */
        let sum = 0
        const bianli = (root, low, high) => {
            if (root === null) return
            if (root.val >= low && root.val <= high) {
                sum += root.val
                bianli(root.left, low, high)
                bianli(root.right, low, high)
            } else if (root.val > high){
                bianli(root.left, low, high)
            } else if (root.val < low) {
                bianli(root.right, low, high)
            }
        }
        bianli(root, low, high)
        return sum
    };
    ```

2. 官方解答 - [深度优先遍历/搜索]
    ```javascript
    var rangeSumBST = function(root, low, high) {
        if (!root) {
            return 0;
        }
        if (root.val > high) {
            return rangeSumBST(root.left, low, high);
        }
        if (root.val < low) {
            return rangeSumBST(root.right, low, high);
        }
        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    };
    ```

3. 官方解答 - [广度优先遍历/搜索]
    ```javascript
    var rangeSumBST = function(root, low, high) {
        let sum = 0;
        const q = [root];  // 利用栈缓存
        while (q.length) {
            const node = q.shift();
            if (!node) {
                continue;
            }
            if (node.val > high) {
                q.push(node.left);
            } else if (node.val < low) {
                q.push(node.right);
            } else {
                sum += node.val;
                q.push(node.left);
                q.push(node.right);
            }
        }
        return sum;
    };
    ```

#### 其他：
1.  二叉树遍历方法复习


### <div id="2021-4-28">2021.4.28</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/sum-of-square-numbers/)
#### 题目理解：
```javascript
var judgeSquareSum = function(c) {
    if (c === 0) return true
    for (var i = 0; i < Math.sqrt(c); i++) {
        var t = Math.sqrt(c - i*i)
        if (parseInt(t) === t) {
            return true
        } 
    }
    return false
};
```
#### 解决办法：
1. 官方解答 - [sqrt]
    ```javascript
    var judgeSquareSum = function(c) {
        for (let a = 0; a * a <= c; a++) {
            const b = Math.sqrt(c - a * a);
            if (b === parseInt(b)) {
                return true;
            }
        }
        return false;
    };
    ```

2. 官方解答 - [双指针]
    ```javascript
    var judgeSquareSum = function(c) {
        let left = 0;
        let right = Math.floor(Math.sqrt(c));
        while (left <= right) {
            const sum = left * left + right * right;
            if (sum === c) {
                return true;
            } else if (sum > c) {
                right--;
            } else {
                left++;
            }
        }
        return false;
    };
    ```

3. 官方解答 - [数学-因式分解]
    ```javascript
    var judgeSquareSum = function(c) {
        for (let base = 2; base * base <= c; base++) {
            // 如果不是因子，枚举下一个
            if (c % base !== 0) {
                continue;
            }

            // 计算 base 的幂
            let exp = 0;
            while (c % base == 0) {
                c /= base;
                exp++;
            }

            // 根据 Sum of two squares theorem 验证
            if (base % 4 === 3 && exp % 2 !== 0) {
                return false;
            }
        }

        // 例如 11 这样的用例，由于上面的 for 循环里 base * base <= c ，base == 11 的时候不会进入循环体
        // 因此在退出循环以后需要再做一次判断
        return c % 4 !== 3;
    };
    ```

#### 其他：
1.  无

### <div id="2021-4-29">2021.4.29</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/frog-jump/)
#### 题目理解：
```javascript
var canCross = function(stones) {
    /**
     * 能跳过石子!
     * 第一步不能跨越的话，那么起始 k 就定下来了，
     * 之后就是看 k 或者 k-1 或者 k+1 是否有石子
     * 
     * 所以每走一步（除去第一步）都可能有 <=3 种走法
     * 动态规划？
     */
    let k = stones[1]
    for (let i = 2; i < stones.length - 1; i++) {
        let step = stones[i] - stones[i - 1]
        if (step >= k - 1 && step <= k + 1) {
            k = step
        } else {
            return false
        }
    }
    return true
};
```
#### 解决办法：
1. 官方解答 - [记忆化搜索 + 二分查找]
    ```javascript
    var canCross = function(stones) {
        const n = stones.length;
        rec = new Array(n).fill(0).map(() => new Map());

        // 搜索
        const dfs = (stones, i, lastDis) => {
            if (i === stones.length - 1) {
                return true;
            }
            if (rec[i].has(lastDis)) {
                return rec[i].get(lastDis);
            }
            for (let curDis = lastDis - 1; curDis <= lastDis + 1; curDis++) {
                if (curDis > 0) {
                    const j = lower_bound(stones, curDis + stones[i]);
                    if (j !== stones.length && stones[j] === curDis + stones[i] && dfs(stones, j, curDis)) {
                        rec[i].set(lastDis, true);
                        return rec[i].get(lastDis);
                    }
                }
            }
            rec[i].set(lastDis, false);
            return rec[i].get(lastDis);
        }

        return dfs(stones, 0, 0);
    };

    // 二分查找
    function lower_bound(nums, target) {
        let lo = 0, hi = nums.length;

        while (lo < hi) {
            const mid = lo + Math.floor((hi - lo) / 2);

            if (nums[mid] >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }
    ```

2. 官方解答 - [动态规划]
    ```javascript
    var canCross = function(stones) {
        const n = stones.length;
        const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));
        dp[0][0] = true;
        for (let i = 1; i < n; ++i) {
            if (stones[i] - stones[i - 1] > i) {
                return false;
            }
        }
        for (let i = 1; i < n; ++i) {
            for (let j = i - 1; j >= 0; --j) {
                const k = stones[i] - stones[j];
                if (k > j + 1) {
                    break;
                }
                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
                if (i === n - 1 && dp[i][k]) {
                    return true;
                }
            }
        }
        return false;
    };
    ```

#### 其他：
1.  至今动态规划都没有好好理清楚过，自己不受苦谁替你受吗？


### <div id="2021-4-30">2021.4.30</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/single-number-ii/)
#### 题目理解：
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    /* 哈希 */
    let map = new Map()
    let num = -1
    for (let i = 0; i < nums.length; i++) {
        if (!map.has(nums[i])) {
            map.set(nums[i], 0)
        } else {
            map.set(nums[i], 1)
        }
    }
    for (let [key, value] of map) {
        if (value === 0){
            num = key
            break
        }
    }
    return num
};
```
#### 解决办法：
1. 官方解答 - [依次确定每一个二进制位]
    ```javascript
    var singleNumber = function(nums) {
        let ans = 0;
        for (let i = 0; i < 32; ++i) {
            let total = 0;
            for (const num of nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    };
    ```

2. 官方解答 - [数字电路设计]
    ```javascript
    var singleNumber = function(nums) {
        let a = 0, b = 0;
        for (const num of nums) {
            const aNext = (~a & b & num) | (a & ~b & ~num), bNext = ~a & (b ^ num);
            a = aNext;
            b = bNext;
        }
        return b;
    };
    ```

3. 官方解答 - [数字电路设计优化]
    ```javascript
    var singleNumber = function(nums) {
        let a = 0, b = 0;
        for (const num of nums) {
            b = ~a & (b ^ num);
            a = ~b & (a ^ num);
        }
        return b;
    };
    ```

#### 其他：
1.  还可以这样？

### <div id="2021-5-6">2021.5.6（劳动节复苏）</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/decode-xored-array/)
#### 题目理解：
```javascript
/**
 * @param {number[]} encoded
 * @param {number} first
 * @return {number[]}
 */
var decode = function(encoded, first) {
    // 异或 ^ ： 同为 0, 异为 1
    let arr = []
    arr[0] = first
    for (let i = 1; i < encoded.length + 1; i++) {
        arr[i] = encoded[i - 1] ^ arr[i - 1]
    }
    return arr
};
```
#### 解决办法：
1. 官方解答 - []
    ```javascript
    
    ```

2. 官方解答 - [数字电路设计]
    ```javascript
    var singleNumber = function(nums) {
        let a = 0, b = 0;
        for (const num of nums) {
            const aNext = (~a & b & num) | (a & ~b & ~num), bNext = ~a & (b ^ num);
            a = aNext;
            b = bNext;
        }
        return b;
    };
    ```

#### 其他：
无

### <div id="2021-5-7">2021.5.7</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/xor-operation-in-an-array/)
#### 题目理解：
```javascript
/**
 * @param {number} n
 * @param {number} start
 * @return {number}
 */
var xorOperation = function(n, start) {
    /**
     * 等差数列，可能有什么规律吧，直接计算吧
     */
    let res = start
    for (let i = 1; i < n; i++) {
        res ^= start + 2 * i
    }
    return res
};
```
#### 解决办法：
1. 官方解答 - [数学]
    ```javascript
    var xorOperation = function(n, start) {
        let s = start >> 1, e = n & start & 1;
        let ret = sumXor(s - 1) ^ sumXor(s + n - 1);
        return ret << 1 | e;
    };

    const sumXor = (x) => {
        if (x % 4 === 0) {
            return x;
        }
        if (x % 4 === 1) {
            return 1;
        }
        if (x % 4 === 2) {
            return x + 1;
        }
        return 0;
    }
    ```

#### 其他：
1. 这种只能看出来可能最好的解题方向，还真不知道怎么解。


### <div id="2021-5-8">2021.5.8</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/)
#### 题目理解：
```javascript
/**
 * 将 jobs 集合划分为 k 个子集，
 * 计算 众多情况中子集的和差最小的情况
 * 分配方法有很多
 * 动态规划-全遍历
 */
```
#### 解决办法：
1. 官方解答 - [二分查找+回溯+剪枝]
    ```javascript
    var minimumTimeRequired = function(jobs, k) {
        jobs.sort((a, b) => a - b);
        let low = 0, high = jobs.length - 1;
        while (low < high) {
            const temp = jobs[low];
            jobs[low] = jobs[high];
            jobs[high] = temp;
            low++;
            high--;
        }
        let l = jobs[0], r = jobs.reduce(function(prev, curr, idx, jobs){ return prev + curr });
        while (l < r) {
            const mid = Math.floor((l + r) >> 1);
            if (check(jobs, k, mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    };

    const check = (jobs, k, limit) => {
        const workloads = new Array(k).fill(0);
        return backtrack(jobs, workloads, 0, limit);
    }

    const backtrack = (jobs, workloads, i, limit) => {
        if (i >= jobs.length) {
            return true;
        }
        let cur = jobs[i];
        for (let j = 0; j < workloads.length; ++j) {
            if (workloads[j] + cur <= limit) {
                workloads[j] += cur;
                if (backtrack(jobs, workloads, i + 1, limit)) {
                    return true;
                }
                workloads[j] -= cur;
            }
            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
            // 或者当前工作恰能使该工人的工作量达到了上限
            // 这两种情况下我们无需尝试继续分配工作
            if (workloads[j] === 0 || workloads[j] + cur === limit) {
                break;
            }
        }
        return false;
    }
    ```

2. 官方解答 - [动态规划+状态压缩]
    ```javascript
    var minimumTimeRequired = function(jobs, k) {
        const n = jobs.length;
        const sum = new Array(1 << n).fill(0);
        for (let i = 1; i < (1 << n); i++) {
            const x = NumberOfTrailingZeros(i), y = i - (1 << x);
            sum[i] = sum[y] + jobs[x];
        }

        const dp = new Array(k).fill(0).map(() => new Array(1 << n).fill(0));
        for (let i = 0; i < (1 << n); i++) {
            dp[0][i] = sum[i];
        }

        for (let i = 1; i < k; i++) {
            for (let j = 0; j < (1 << n); j++) {
                let minn = Number.MAX_VALUE;
                for (let x = j; x != 0; x = (x - 1) & j) {
                    minn = Math.min(minn, Math.max(dp[i - 1][j - x], sum[x]));
                }
                dp[i][j] = minn;
            }
        }
        return dp[k - 1][(1 << n) - 1];
    };

    const NumberOfTrailingZeros = (number) => {
        const num = parseInt(number).toString(2);
        const multiply_De_Bruijn_position = [
            0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
            31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9];
        return multiply_De_Bruijn_position[(((num & (-num)) * 0x077CB531) >> 27) & 31]
    }
    ```

3. 宫水三叶 - [DFS]
    ```java
    class Solution {
        int[] jobs;
        int n, k;
        int ans = 0x3f3f3f3f;
        public int minimumTimeRequired(int[] _jobs, int _k) {
            jobs = _jobs;
            n = jobs.length;
            k = _k;
            int[] sum = new int[k];
            dfs(0, sum, 0);
            return ans;
        }
        /**
        * u   : 当前处理到那个 job
        * sum : 工人的分配情况          例如：sum[0] = x 代表 0 号工人工作量为 x
        * max : 当前的「最大工作时间」
        */
        void dfs(int u, int[] sum, int max) {
            if (max >= ans) return;
            if (u == n) {
                ans = max;
                return;
            }
            for (int i = 0; i < k; i++) {
                sum[i] += jobs[u];
                dfs(u + 1, sum, Math.max(sum[i], max));
                sum[i] -= jobs[u];
            }
        }
    }
    ```
    人工转为 javascript 语言：
    ```javascript
    var minimumTimeRequired = function(jobs, k) {
        /**
         * 将 jobs 集合划分为 k 个子集，
        * 计算 众多情况中子集的和差最小的情况
        * 分配方法有很多
        * 动态规划-全遍历
        */
        _jobs = jobs;
        _n = jobs.length;
        _k = k;
        ans = Number.MAX_VALUE;
        let sum = new Array(k).fill(0);
        dfs(0, sum, 0);
        return ans;
    };
    function dfs(u, sum, max){
        if (max >= ans) return;
        if (u === _n) {
            ans = max;
            return;
        }
        for (let i = 0; i < _k; i++) {
            sum[i] += _jobs[u];
            dfs(u + 1, sum, Math.max(sum[i], max));
            sum[i] -= _jobs[u];
        }
    }
    ```
    虽然可以计算出来，但是超出时间限制。

#### 其他：
1. 脑子死掉了，动都不动一下

### <div id="2021-5-10">2021.5.10</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/leaf-similar-trees/)
#### 题目理解：
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
    /**
     * A. 进行叶值序列的遍历, 然后比较
     * B. 一个一个叶值进行比较,如果不同返回 false,否则 true
     */
    let leafArr1 = traversal(root1, [])
    let leafArr2 = traversal(root2, [])
    if (leafArr1.length !== leafArr2.length) return false
    for (let i = 0; i < leafArr1.length; i++) {
        if (leafArr2[i] !== leafArr1[i]) return false
    }
    return true
};

function traversal(root, leafArr){
    if (root.left === null && root.right === null) {
        leafArr.push(root.val)
    } else {
        if (root.left) {
            traversal(root.left, leafArr)
        }
        if (root.right) {
            traversal(root.right, leafArr)
        }
    }
    return leafArr
}
```
#### 解决办法：
1. 官方解答 - [DFS深度优先遍历]
    ```javascript
    var leafSimilar = function(root1, root2) {
        const seq1 = [];
        if (root1) {
            dfs(root1, seq1);
        }

        const seq2 = [];
        if (root2) {
            dfs(root2, seq2);
        }
        return seq1.toString() === seq2.toString();
    };

    const dfs = (node, seq) => {
        if (!node.left && !node.right) {
            seq.push(node.val);
        } else {
            if (node.left) {
                dfs(node.left, seq);
            }
            if (node.right) {
                dfs(node.right, seq);
            }
        }
    }
    ```

#### 其他：
1. 数组可以转为字符串进行直接比较！！！


### <div id="2021-5-11">2021.5.11</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/decode-xored-permutation/)
#### 题目理解：
```python
'''
想的是
全部遍历？
'''
```
#### 解决办法：
1. 官方解答 - [异或的规律]
    ```javascript
    /**
     * @param {number[]} encoded
    * @return {number[]}
    */
    var decode = function(encoded) {
        const n = encoded.length + 1;
        let total = 0;
        for (let i = 1; i <= n; i++) {
            total ^= i;
        }
        let odd = 0;
        for (let i = 1; i < n - 1; i += 2) {
            odd ^= encoded[i];
        }
        const perm = new Array(n).fill(0);
        perm[0] = total ^ odd;
        for (let i = 0; i < n - 1; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }
        return perm;
    };
    ```

#### 其他：
1. 异或的数  a ^ b = c 那么 c ^ a = b 或者 c ^ b = a

### <div id="2021-5-12">2021.5.12</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)
#### 题目理解：
```javascript
/**
 * @param {number[]} arr
 * @param {number[][]} queries
 * @return {number[]}
 */
var xorQueries = function(arr, queries) {
    /**
     * 这就是计算吧
     */
    let res = []
    for(let i = 0; i < queries.length; i++) {
        let j = queries[i][0]
        let a = arr[j]
        j += 1
        while(j <= queries[i][1]) {
            a ^= arr[j]
            j += 1
        }
        res.push(a)
    }
    return res
};
```
#### 解决办法：
1. 官方解答 - [前缀异或]
    ```javascript
    var xorQueries = function(arr, queries) {
        const n = arr.length;
        const xors = new Array(n + 1).fill(0);
        for (let i = 0; i < n; i++) {
            xors[i + 1] = xors[i] ^ arr[i];
        }
        const m = queries.length;
        const ans = new Array(m).fill(0);
        for (let i = 0; i < m; i++) {
            ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1];
        }
        return ans;
    };
    ```
    该方法先计算了前缀异或，然后直接计算相关值，少去每次循环。

#### 其他：
1. 异或的数  a ^ b = c 那么 c ^ a = b 或者 c ^ b = a


### <div id="2021-5-13">2021.5.13</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)
#### 题目理解：
```javascript
/**
 * 动态规划
 */
```
#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    /**
     * @param {number} steps
    * @param {number} arrLen
    * @return {number}
    */
    var numWays = function(steps, arrLen) {
        /**
        * 动态规划
        */
        const MODULO = 1000000007;
        let maxColumn = Math.min(arrLen - 1, steps);
        let dp = new Array(maxColumn + 1).fill(0);
        dp[0] = 1;
        for (let i = 1; i <= steps; i++) {
            const dpNext = new Array(maxColumn + 1).fill(0);
            for (let j = 0; j <= maxColumn; j++) {
                dpNext[j] = dp[j];
                if (j - 1 >= 0) {
                    dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
                }
            }
            dp = dpNext;
        }
        return dp[0];
    };
    ```

#### 其他：
1. ...

### <div id="2021-5-14">2021.5.14</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/integer-to-roman/submissions/)
#### 题目理解：
```javascript
/**
 * 映射
 * /
```
#### 解决办法：
1. 官方解答 - [模拟]
    ```javascript
    var intToRoman = function(num) {
        const valueSymbols = [[1000, "M"], [900, "CM"], [500, "D"], [400, "CD"], [100, "C"], [90, "XC"], [50, "L"], [40, "XL"], [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]];
        const roman = [];
        for (const [value, symbol] of valueSymbols) {
            while (num >= value) {
                num -= value;
                roman.push(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return roman.join('');
    };
    ```

2. 官方解答 - [硬编码数字]
    ```javascript
    var intToRoman = function(num) {
        const thousands = ["", "M", "MM", "MMM"];
        const hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
        const tens     = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
        const ones     = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

        const roman = [];
        roman.push(thousands[Math.floor(num / 1000)]);
        roman.push(hundreds[Math.floor(num % 1000 / 100)]);
        roman.push(tens[Math.floor(num % 100 / 10)]);
        roman.push(ones[num % 10]);
        return roman.join('');
    };
    ```
#### 其他：
1. ...

### <div id="2021-5-20">2021.5.20</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/top-k-frequent-words/)
#### 题目理解：
```javascript
var topKFrequent = function(words, k) {
    /**
     * 字典，或者说是 hash
     */
    let map = new Map()
    words.sort()
    for (let i = 0; i < words.length; i++) {
        if (!map.has(words[i])) {
            map.set(words[i], 1)
        } else {
            map.set(words[i], map.get(words[i]) + 1)
        }
    }
    var arrayObj = Array.from(map);
    arrayObj.sort((a,b) => {
        if (a[1] - b[1] === 0) {
            return a[0] > b[0]
        }
        return b[1] - a[1]
    })
    let res = []
    for (let i = 0; i < k; i++) {
        res.push(arrayObj[i][0])
    }
    return res
};
```
#### 解决办法：
1. 官方解答 - [哈希表+排序]
    ```javascript
    var topKFrequent = function(words, k) {
        const cnt = new Map();
        for (const word of words) {
            cnt.set(word, (cnt.get(word) || 0) + 1);
        }
        const rec = [];
        for (const entry of cnt.keys()) {
            rec.push(entry);
        }
        rec.sort((word1, word2) => {
            return cnt.get(word1) === cnt.get(word2) ? word1.localeCompare(word2) : cnt.get(word2) - cnt.get(word1);
        })
        return rec.slice(0, k);
    };
    ```

2. 官方解答 - [优先队列]
    ```c++
    class Solution {
    public:
        vector<string> topKFrequent(vector<string>& words, int k) {
            unordered_map<string, int> cnt;
            for (auto& word : words) {
                cnt[word]++;
            }
            auto cmp = [](const pair<string, int>& a, const pair<string, int>& b) {
                return a.second == b.second ? a.first < b.first : a.second > b.second;
            };
            priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> que(cmp);
            for (auto& it : cnt) {
                que.emplace(it);
                if (que.size() > k) {
                    que.pop();
                }
            }
            vector<string> ret(k);
            for (int i = k - 1; i >= 0; i--) {
                ret[i] = que.top().first;
                que.pop();
            }
            return ret;
        }
    };
    ```
#### 其他：
1. ...
### <div id="2021-5-21">2021.5.21</div>
#### 题目描述：
[描述](https://leetcode-cn.com/problems/strange-printer/)
#### 题目理解：
```javascript
/**
*/
```
#### 解决办法：
1. 官方解答 - [dp]
    ```javascript
    /**
    * @param {string} s
    * @return {number}
    */
    var strangePrinter = function(s) {
        const n = s.length;
        const f = new Array(n).fill(0).map(() => new Array(n).fill(0));
        for (let i = n - 1; i >= 0; i--) {
            f[i][i] = 1;
            for (let j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    f[i][j] = f[i][j - 1];
                } else {
                    let minn = Number.MAX_SAFE_INTEGER;
                    for (let k = i; k < j; k++) {
                        minn = Math.min(minn, f[i][k] + f[k + 1][j]);
                    }
                    f[i][j] = minn;
                }
            }
        }
        return f[0][n - 1];
    };
    ```

#### 其他：
1. ...

### <div id="2021-5-24">2021.5.24</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/uncrossed-lines/)
#### 题目理解：
```javascript
/**
相交的条件是：
[x1, y1]  [x2, y2]
x1 > x2 并且 y1 < y2
x1 < x2 并且 y1 > y2
    => (x1 - x2)*(y1 - y2) < 0
需要遍历
*/
```
#### 解决办法：
1. 官方解答 - [dp]
    ```javascript
    var maxUncrossedLines = function(nums1, nums2) {
        const m = nums1.length, n = nums2.length;
        const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
        for (let i = 1; i <= m; i++) {
            const num1 = nums1[i - 1];
            for (let j = 1; j <= n; j++) {
                const num2 = nums2[j - 1];
                if (num1 === num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    };
    ```

#### 其他：
1. ...

### <div id="2021-5-25">2021.5.25</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/)
#### 题目理解：
```javascript
/**
动态规划题
*/
```
#### 解决办法：
1. 官方解答 - [dp]
    ```javascript
    /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
    var minChanges = function(nums, k) {
        /**
        动态规划题
        */
        // x 的范围为 [0, 2^10)
        const MAXX = 2**10;

        const n = nums.length;
        let f = new Array(MAXX).fill(Number.MAX_VALUE);
        // 边界条件 f(-1,0)=0
        f[0] = 0;

        for (let i = 0; i < k; i++) {
            // 第 i 个组的哈希映射
            const count = new Map();
            let size = 0;
            for (let j = i; j < n; j += k) {
                count.has(nums[j]) ? count.set(nums[j], count.get(nums[j]) + 1) : count.set(nums[j], 1);
                size++;
            }

            // 求出 t2
            const t2min = Math.min(...f);

            const g = new Array(MAXX).fill(t2min);
            for (let mask = 0; mask < MAXX; mask++) {
                // t1 则需要枚举 x 才能求出
                for (const [x, countx] of count.entries()) {
                    g[mask] = Math.min(g[mask], f[mask ^ x] - countx);
                }
            }

            // 别忘了加上 size
            for (const [index, val] of g.entries()) {
                f[index] = val + size;
            }
        }

        return f[0];
    };
    ```

#### 其他：
1. 动态规划解题需要找到状态转移方程
2. 找到子问题的计算方法，然后存储起来，为大问题计算

### <div id="2021-5-26">2021.5.26</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)
#### 题目理解：
```javascript
/**
字符串是否反转？
    单数层： 反转
    双数层： 不反转
撸这个题目花了两个小时，还没解出来！！TT
*/
```
#### 解决办法：
1. 官方解答 - [Brian Kernighan 算法]
    ```javascript
    var reverseParentheses = function(s) {
        const stk = []
        let str = ''
        for (const ch of s) {
            if (ch === '(') {
                stk.push(str)
                str = ''
            } else if (ch === ')') {
                str = str.split("").reverse().join("")
                str = stk[stk.length - 1] + str
                stk.pop()
            } else {
                str += ch
            }
        }
        return str;
    }
    ```
2. 官方解答 - [预处理括号]
    ```javascript
    var reverseParentheses = function(s) {
        const n = s.length
        const pair = new Array(n).fill(0)
        const stk = []
        for (let i = 0; i < n; i++) {
            if (s[i] === '(') {
                stk.push(i)
            } else if (s[i] === ')') {
                const j = stk.pop()
                pair[i] = j
                pair[j] = i
            }
        }

        const sb = []
        let index = 0, step = 1;
        while (index < n) {
            if (s[index] === '(' || s[index] === ')') {
                index = pair[index]
                step = -step
            } else {
                sn.push(s[index])
            }
            index += step
        }
        return sb.join('')
    }
    ```

#### 其他：
1. 数据结构......
2. 正正反反的自己都搞晕了！ js 的 string 类型还有 reverse 函数！！！


### <div id="2021-5-27">2021.5.27</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/hamming-distance/)
#### 题目理解：
```javascript
var hammingDistance = function(x, y) {
    /**
      这题好像很简单的，就是每位二进制位对比一下
     */
    let res = x ^ y
    let num = 0
    while(res) {
        var tmp = res >>> 1
        var t = tmp << 1
        if (t !== res) {
            num += 1
        }
        res = tmp
    }
    return num;
};
```
#### 解决办法：
1. 官方解答 - [Brian Kernighan 算法]
    ```javascript
    var hammingDistance = function(x, y) {
        let s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;  // 只遍历 s 中的 1 的位数
            ret++;
        }
        return ret;
    };
    ```

#### 其他：
1. 汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。
2. 还可以直接计算1的位数，忘了忘了！

### <div id="2021-5-28">2021.5.28</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/total-hamming-distance/)
#### 题目理解：
```javascript
var totalHammingDistance = function(nums) {
    let sum = 0
    const hammingDistance = (x, y) => {
        let s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;  // 只遍历 s 中的 1 的位数
            ret++;
        }
        return ret;
    }
    for (let i = 0; i < nums.length - 1; i++) {
        for (let j = i+1; j < nums.length; j++) {
            sum += hammingDistance(nums[i], nums[j])  
        }   
    }
    return sum
};
```
TT 超时
#### 解决办法：
1. 官方解答 - [逐位统计]
    ```javascript
    var totalHammingDistance = function(nums) {
        let ans = 0, n = nums.length;
        for (let i = 0; i < 30; ++i) {
            let c = 0;
            for (const val of nums) {
                c += (val >> i) & 1;
            }
            ans += c * (n - c);
        }
        return ans;
    };
    ```

#### 其他：
1. ...

### <div id="2021-5-31">2021.5.31</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/power-of-four/submissions/)
#### 题目理解：
```javascript
var totalHammingDistance = function(nums) {
    /*
    以为直接开方就可以
    */
};
```
#### 解决办法：
1. 官方解答 - [二进制表示中1的位置]
    ```javascript
    var isPowerOfFour = function(n) {
        return n > 0 && (n & (n - 1)) === 0 && (n & 0xaaaaaaaa) === 0;
    };
    ```
2. 官方解答 - [取模性质]
    ```javascript
    var isPowerOfFour = function(n) {
        return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;
    };
    ```

#### 其他：
1. 完全没想到，简单题
2. 找数学规律

### <div id="2021-6-1">2021.6.1</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/)
#### 题目理解：
```javascript
```
#### 解决办法：
1. 官方解答 - [前缀和]
    ```javascript
    var canEat = function(candiesCount, queries) {
        const n = candiesCount.length;
        
        // 前缀和
        const sum = new Array(n).fill(0);;
        sum[0] = candiesCount[0];
        for (let i = 1; i < n; ++i) {
            sum[i] = sum[i - 1] + candiesCount[i];
        }
        
        const q = queries.length;
        const ans = new Array(q).fill(0);
        for (let i = 0; i < q; ++i) {
            const query = queries[i];
            const favoriteType = query[0], favoriteDay = query[1], dailyCap = query[2];
            
            const x1 = favoriteDay + 1;
            const y1 = (favoriteDay + 1) * dailyCap;
            const x2 = favoriteType == 0 ? 1 : sum[favoriteType - 1] + 1;
            const y2 = sum[favoriteType];
            
            ans[i] = !(x1 > y2 || y1 < x2);
        }
        return ans;
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-2">2021.6.2</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/continuous-subarray-sum/)
#### 题目理解：
```javascript
var checkSubarraySum = function(nums, k) {
    /**
        全部遍历-子数组？
        动态规划？
        BFS？
        DFS？
    */
    // let arr = []
    for (let i = 1; i < nums.length; i++) {
        // var tmp = []
        for (let j = 0; j < nums.length - i; j++) {
            var sum = 0
            for (let k = j; k <= j + i; k++) {
                sum += nums[k]
            }
            // tmp.push(sum)
            if(sum % k === 0) {
                return true
            }
        }
        // arr.push(tmp)
    }
    return false
};
```
超时

#### 解决办法：
1. 官方解答 - [前缀和+哈希表]
    ```javascript
    var checkSubarraySum = function(nums, k) {
        const m = nums.length;
        if (m < 2) {
            return false;
        }
        const map = new Map();
        map.set(0, -1);
        let remainder = 0;
        for (let i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;
            if (map.has(remainder)) {
                const prevIndex = map.get(remainder);
                if (i - prevIndex >= 2) {
                    return true;
                }
            } else {
                map.set(remainder, i);
            }
        }
        return false;
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-3">2021.6.3</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/contiguous-array/)
#### 题目理解：
```javascript
var findMaxLength = function(nums) {
    /**
     * 要求： 子数组中 0 和 1 的数量要相等
     * 方法： 
     *      昨天的方法： 前缀和 + 哈希表
     *      和？前缀计数？   
     */
    let res = 0
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length - i; j++) {
            var x1 = 0, x2 = 0
            for (let k = j; k <= j + i; k++) {
                if (nums[k] === 0) {
                    x1 += 1
                } else {
                    x2 += 1
                }
            }
            // console.log("x1: ", x1)
            // console.log("x2: ", x2)
            if(x1 === x2 && res < i) {
                res = x1 * 2
            }
        }
    }
    return res
};
```
超时

#### 解决办法：
1. 官方解答 - [前缀和+哈希表]
    ```javascript
    var findMaxLength = function(nums) {
        /**
        * 要求： 子数组中 0 和 1 的数量要相等
        * 方法： 
        *      昨天的方法： 前缀和 + 哈希表
        *      和？前缀计数？   
        */
        let maxLength = 0;
        const map = new Map();
        let counter = 0;
        map.set(counter, -1);
        const n = nums.length;
        for (let i = 0; i < n; i++) {
            const num = nums[i];
            if (num == 1) {
                counter++;
            } else {
                counter--;
            }
            if (map.has(counter)) {
                const prevIndex = map.get(counter);
                maxLength = Math.max(maxLength, i - prevIndex);
            } else {
                map.set(counter, i);
            }
        }
        return maxLength;
    };
    ```

#### 其他：
1. ...


### <div id="2021-6-7">2021.6.7</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/target-sum/)
#### 题目理解：
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function(nums, target) {
    /**
        nums 的总和 为多大 sum，
        要制造 target 的话，那么 t = sum - target 就是 nums 中需要组合的减法的部分
        怎么组成 t / 2 , 有多少中不同的组合方法即返回值
        如果 t / 2 不是整数 那么就是 0
     */
    let res = 0
    let tmp = -target
    tmp += nums.reduce((preV, curV) => {
        return preV + curV
    }) 
    tmp /= 2
    if (Int(tmp) !== tmp) {
        return 0
    } else {
        // 动态规划实现 tmp 在 nums 数组中的路径匹配
    }
    return res
};
```
但是动态规划TT

#### 解决办法：
1. 官方解答 - [回溯]
    ```javascript
    var findTargetSumWays = function(nums, target) {
        let count = 0;
        const backtrack = (nums, target, index, sum) => {
            if (index === nums.length) {
                if (sum === target) {
                    count++;
                }
            } else {
                backtrack(nums, target, index + 1, sum + nums[index]);
                backtrack(nums, target, index + 1, sum - nums[index]);
            }
        }
        
        backtrack(nums, target, 0, 0);
        return count;
    };
    ```

2. 官方解答 - [动态规划]
    ```javascript
    var findTargetSumWays = function(nums, target) {
        let sum = 0;
        for (const num of nums) {
            sum += num;
        }
        const diff = sum - target;
        if (diff < 0 || diff % 2 !== 0) {
            return 0;
        }
        const n = nums.length, neg = diff / 2;
        const dp = new Array(n + 1).fill(0).map(() => new Array(neg + 1).fill(0));
        dp[0][0] = 1;
        for (let i = 1; i <= n; i++) {
            const num = nums[i - 1];
            for (let j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][neg];
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-8">2021.6.8</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/last-stone-weight-ii/submissions/)
#### 题目理解：
```javascript
/**
动态规划
最小路径问题
*/
```
但是动态规划TT

#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    /**
    * @param {number[]} stones
    * @return {number}
    */
    var lastStoneWeightII = function(stones) {
        /**
            动态规划
            最小路径问题
        */
        let sum = 0;
        for (const weight of stones) {
            sum += weight;
        }
        const m = Math.floor(sum / 2);
        const dp = new Array(m + 1).fill(false);
        dp[0] = true;
        for (const weight of stones) {
            for (let j = m; j >= weight; --j) {
                dp[j] = dp[j] || dp[j - weight];
            }
        }
        for (let j = m;; --j) {
            if (dp[j]) {
                return sum - 2 * j;
            }
        }
    };
    ```
    ```javascript
    var lastStoneWeightII = function(stones) {
        let sum = 0;
        for (const weight of stones) {
            sum += weight;
        }
        const n = stones.length, m = Math.floor(sum / 2);
        const dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(false));
        dp[0][0] = true;
        for (let i = 0; i < n; ++i) {
            for (let j = 0; j <= m; ++j) {
                if (j < stones[i]) {
                    dp[i + 1][j] = dp[i][j];
                } else {
                    dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];
                }
            }
        }
        for (let j = m;; --j) {
            if (dp[n][j]) {
                return sum - 2 * j;
            }
        }
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-9">2021.6.9</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/profitable-schemes/)
#### 题目理解：
```javascript
/**
计划组合需要考虑：
    1. 利润满足 profit的和 >= minProfit
    2. 工作人员参与 group的和 <= n
*/
```

#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    var profitableSchemes = function(n, minProfit, group, profit) {
        const len = group.length, MOD = 1e9 + 7;
        const dp = new Array(len + 1).fill(0).map(() => new Array(n + 1).fill(0).map(() => new Array(minProfit + 1).fill(0)));
        dp[0][0][0] = 1;
        for (let i = 1; i <= len; i++) {
            const members = group[i - 1], earn = profit[i - 1];
            for (let j = 0; j <= n; j++) {
                for (let k = 0; k <= minProfit; k++) {
                    if (j < members) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][Math.max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        let sum = 0;
        for (let j = 0; j <= n; j++) {
            sum = (sum + dp[len][j][minProfit]) % MOD;
        }
        return sum;
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-10">2021.6.10</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/coin-change-2/submissions/)
#### 题目理解：
```javascript
/**
dp
*/
```

#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    var change = function(amount, coins) {
        const dp = new Array(amount + 1).fill(0);
        dp[0] = 1;
        for (const coin of coins) {
            for (let i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        return dp[amount];
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-11">2021.6.11</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/perfect-squares/)
#### 题目理解：
```javascript
/**
dp
*/
```

#### 解决办法：
1. 官方解答 - [动态规划]
    ```javascript
    /**
    * @param {number} n
    * @return {number}
    */
    var numSquares = function(n) {
        /** 动态规划 */
        const f = new Array(n + 1).fill(0);
        for (let i = 1; i <= n; i++) {
            let minn = Number.MAX_VALUE;
            for (let j = 1; j * j <= i; j++) {
                minn = Math.min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    };
    ```

#### 其他：
1. ...

### <div id="2021-6-15">2021.6.15</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)
#### 题目理解：
```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var peakIndexInMountainArray = function(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            return i
        }
    }
    return 0
};
```

#### 解决办法：
1. 官方解答 - [二分查找]
    ```javascript
    var peakIndexInMountainArray = function(arr) {
        const n = arr.length;
        let left = 1, right = n - 2, ans = 0;

        while (left <= right) {
            const mid = Math.floor((left + right) /2 );
            if (arr[mid] > arr[mid + 1]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    };
    ```

#### 其他：
1. ...


### <div id="2021-6-16">2021.6.16</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/stone-game/)
#### 题目理解：
```javascript
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
    /**
        dp
     */
    return true
};
```

#### 解决办法：
1. 官方解答 - [dp]
    ```javascript
    var stoneGame = function(piles) {
        const length = piles.length;
        const dp = new Array(length).fill(0).map(() => new Array(length).fill(0));
        for (let i = 0; i < length; i++) {
            dp[i][i] = piles[i];
        }
        for (let i = length - 2; i >= 0; i--) {
            for (let j = i + 1; j < length; j++) {
                dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] > 0;
    };
    ```
    或者
    ```javascript
    var stoneGame = function(piles) {
        const length = piles.length;
        const dp = new Array(length).fill(0);
        for (let i = 0; i < length; i++) {
            dp[i] = piles[i];
        }
        for (let i = length - 2; i >= 0; i--) {
            for (let j = i + 1; j < length; j++) {
                dp[j] = Math.max(piles[i] - dp[j], piles[j] - dp[j - 1]);
            }
        }
        return dp[length - 1] > 0;
    };
    ```

#### 其他：
1. 必赢的先手大概率有赢的可能

### <div id="2021-6-17">2021.6.17</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/valid-number/)
#### 题目理解：
```javascript
```

#### 解决办法：
1. 官方解答 - [确定有限状态自动机]
    ```javascript
    /**
    * @param {string} s
    * @return {boolean}
    */
    var isNumber = function(s) {
        /** 正则表达式 */
        /**
        1. 正则表达式
        2. 以 e | E 分的话, 长度为 <= 2
        以 . 分的话, 长度为 <= 2
        以 + | - 分的话, 长度为 1
        */
        const State = {
            STATE_INITIAL : "STATE_INITIAL",
            STATE_INT_SIGN : "STATE_INT_SIGN",
            STATE_INTEGER : "STATE_INTEGER",
            STATE_POINT : "STATE_POINT",
            STATE_POINT_WITHOUT_INT : "STATE_POINT_WITHOUT_INT",
            STATE_FRACTION : "STATE_FRACTION",
            STATE_EXP : "STATE_EXP",
            STATE_EXP_SIGN : "STATE_EXP_SIGN",
            STATE_EXP_NUMBER : "STATE_EXP_NUMBER",
            STATE_END : "STATE_END"
        }

        const CharType = {
            CHAR_NUMBER : "CHAR_NUMBER",
            CHAR_EXP : "CHAR_EXP",
            CHAR_POINT : "CHAR_POINT",
            CHAR_SIGN : "CHAR_SIGN",
            CHAR_ILLEGAL : "CHAR_ILLEGAL"
        }

        const toCharType = (ch) => {
            if (!isNaN(ch)) {
                return CharType.CHAR_NUMBER;
            } else if (ch.toLowerCase() === 'e') {
                return CharType.CHAR_EXP;
            } else if (ch === '.') {
                return CharType.CHAR_POINT;
            } else if (ch === '+' || ch === '-') {
                return CharType.CHAR_SIGN;
            } else {
                return CharType.CHAR_ILLEGAL;
            }
        }   

        const transfer = new Map();
        const initialMap = new Map();
        initialMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);
        initialMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
        initialMap.set(CharType.CHAR_SIGN, State.STATE_INT_SIGN);
        transfer.set(State.STATE_INITIAL, initialMap);
        const intSignMap = new Map();
        intSignMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);
        intSignMap.set(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);
        transfer.set(State.STATE_INT_SIGN, intSignMap);
        const integerMap = new Map();
        integerMap.set(CharType.CHAR_NUMBER, State.STATE_INTEGER);
        integerMap.set(CharType.CHAR_EXP, State.STATE_EXP);
        integerMap.set(CharType.CHAR_POINT, State.STATE_POINT);
        transfer.set(State.STATE_INTEGER, integerMap);
        const pointMap = new Map() 
        pointMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);
        pointMap.set(CharType.CHAR_EXP, State.STATE_EXP);
        transfer.set(State.STATE_POINT, pointMap);
        const pointWithoutIntMap = new Map();
        pointWithoutIntMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);
        transfer.set(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);
        const fractionMap = new Map();
        fractionMap.set(CharType.CHAR_NUMBER, State.STATE_FRACTION);
        fractionMap.set(CharType.CHAR_EXP, State.STATE_EXP);
        transfer.set(State.STATE_FRACTION, fractionMap);
        const expMap = new Map(); 
        expMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        expMap.set(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);
        transfer.set(State.STATE_EXP, expMap);
        const expSignMap = new Map();
        expSignMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        transfer.set(State.STATE_EXP_SIGN, expSignMap);
        const expNumberMap = new Map();
        expNumberMap.set(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);
        transfer.set(State.STATE_EXP_NUMBER, expNumberMap);

        const length = s.length;
        let state = State.STATE_INITIAL;

        for (let i = 0; i < length; i++) {
            const type = toCharType(s[i]);
            if (!transfer.get(state).has(type)) {
                return false;
            } else {
                state = transfer.get(state).get(type);
            }
        }
        return state === State.STATE_INTEGER || state === State.STATE_POINT || state === State.STATE_FRACTION || state === State.STATE_EXP_NUMBER || state === State.STATE_END;
    };
    ```

#### 其他：
1. 是真不会，但是分类讨论应该可以，敲不出来


### <div id="2021-6-18">2021.6.18</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/smallest-good-base/)
#### 题目理解：
```javascript
```

#### 解决办法：
1. 官方解答 - [数学找规律]
    ```javascript
    /**
     * @param {string} n
    * @return {string}
    */
    var smallestGoodBase = function(n) {
        const nVal = parseInt(n);
        const mMax = Math.floor(Math.log(nVal) / Math.log(2));
        for (let m = mMax; m > 1; m--) {
            const k = BigInt(Math.floor(Math.pow(nVal, 1.0 / m)));
            if (k > 1) {
                let mul = BigInt(1), sum = BigInt(1);
                for (let i = 1; i <= m; i++) {
                    mul *= k;
                    sum += mul;
                }
                if (sum === BigInt(n)) {
                    return k + '';
                }
            }
        }
        return (BigInt(n) - BigInt(1)) + ''
    };
    ```

#### 其他：
1. 是真不会，敲不出来，想不到是个数学题

#### 题目描述：
[描述](https://leetcode-cn.com/problems/smallest-good-base/)
#### 题目理解：
```javascript
```

#### 解决办法：
1. 官方解答 - [数学找规律]
    ```javascript
    /**
     * @param {string} n
    * @return {string}
    */
    var smallestGoodBase = function(n) {
        const nVal = parseInt(n);
        const mMax = Math.floor(Math.log(nVal) / Math.log(2));
        for (let m = mMax; m > 1; m--) {
            const k = BigInt(Math.floor(Math.pow(nVal, 1.0 / m)));
            if (k > 1) {
                let mul = BigInt(1), sum = BigInt(1);
                for (let i = 1; i <= m; i++) {
                    mul *= k;
                    sum += mul;
                }
                if (sum === BigInt(n)) {
                    return k + '';
                }
            }
        }
        return (BigInt(n) - BigInt(1)) + ''
    };
    ```

#### 其他：
1. 是真不会，敲不出来，想不到是个数学题

### <div id="2021-11-15">2021.11.15</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/bulb-switcher/)
#### 题目理解：
```javascript
```

#### 解决办法：
1. 官方解答 - [数学规律]
    ```javascript
    /**
    * @param {number} n
    * @return {number}
    */
   var bulbSwitch = function(n) {
       /**
       题目没看懂，为什么不是第三轮3个都亮着
       有规律n的2次方范围是n
       **/
       return Math.floor(Math.sqrt(n));
    };  
    ```

#### 其他：
1. 规律找错了
   

### <div id="2021-11-16">2021.11.16</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/perfect-rectangle/)
#### 题目理解：
```javascript
```

#### 解决办法：
1. 官方解答 - [哈希]
    ```javascript
    /**
    * @param {number[][]} rectangles
    * @return {boolean}
    */
   var isRectangleCover = function(rectangles) {
       /**
       左上和右下是否在别的地方看到
       错误的情况：
       1. 空
       2. 重合

       解决办法 1 ：
       1. 找出 wmin,wmax,hmin,hmax 
       2. 标记初始化为0, + 1
       3. 判断

       解决办法 2 ：
       1. 拆分最小单元 
       2. 如果出现两回就错
       3. 判断
       **/
   let area = 0;
       let minX = rectangles[0][0], minY = rectangles[0][1], maxX = rectangles[0][2], maxY = rectangles[0][3];
       const cnt = new Map();
       for (const rect of rectangles) {
           const x = rect[0], y = rect[1], a = rect[2], b = rect[3];
           area += (a - x) * (b - y);

           minX = Math.min(minX, x);
           minY = Math.min(minY, y);
           maxX = Math.max(maxX, a);
           maxY = Math.max(maxY, b);

           cnt.set([x, y].toString(), (cnt.get([x, y].toString()) || 0) + 1);
           cnt.set([x, b].toString(), (cnt.get([x, b].toString()) || 0) + 1);
           cnt.set([a, y].toString(), (cnt.get([a, y].toString()) || 0) + 1);
           cnt.set([a, b].toString(), (cnt.get([a, b].toString()) || 0) + 1);
       }
       
       const pointMinMin = [minX, minY].toString();
       const pointMinMax = [minX, maxY].toString();
       const pointMaxMin = [maxX, minY].toString();
       const pointMaxMax = [maxX, maxY].toString();
       if (area !== (maxX - minX) * (maxY - minY) || (cnt.get(pointMinMin) || 0) !== 1 || (cnt.get(pointMinMax) || 0) !== 1 || (cnt.get(pointMaxMin) || 0) !== 1 || (cnt.get(pointMaxMax) || 0) !== 1) {
           console.log(cnt.get([minX, minY].toString()))
           return false;
       }

       cnt.delete(pointMinMin);
       cnt.delete(pointMinMax);
       cnt.delete(pointMaxMin);
       cnt.delete(pointMaxMax);

       for (const [_, value] of cnt.entries()) {
           if (value !== 2 && value !== 4) {
               
               return false;
           }
       }
       
       return true;
   };
    ```

#### 其他：
1. 实现没完成
 
 


 

# 本次
### <div id="2021-11-17">2021.11.17</div>

#### 题目描述：
[描述](https://leetcode-cn.com/problems/perfect-rectangle/)
#### 题目理解：
```javascript
/**
 * @param {string[]} words
 * @return {number}
 */
var maxProduct = function(words) {
    /** 遍历 */
    var res = 0
    for (var i = 0; i < words.length - 1; i++) {
        for (var j = i + 1; j < words.length; j++) {
            var len1 = words[i].length
            var len2 = words[j].length
            var k = 0;
            var len = Math.min(len2, len1)
            if (len2 > len1) {
                for (; k < len1; k++) {
                    if (words[j].indexOf(words[i][k]) !== -1) break 
                }
            } else {
                for (; k < len2; k++) {
                    if (words[i].indexOf(words[j][k]) !== -1) break 
                }
            }
            if (k >= len) {
                res = Math.max(len1 * len2, res)
            }
        }
    }
    return res;
};
```
直接遍历
#### 解决办法：
1. 最优解答 - [最优]
    ```javascript
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function(words) {
       const bitmaskMap = new Map()
       for (let i = 0; i < words.length; i++) {
           let bitmask = 0
           for (const c of words[i]) {
               bitmask |= 1 << (c.charCodeAt() - 'a'.charCodeAt())
           }
           if (bitmaskMap.has(bitmask)) {
               bitmaskMap.set(bitmask, Math.max(bitmaskMap.get(bitmask), words[i].length))
           } else {
               bitmaskMap.set(bitmask, words[i].length)
           }
       }

       let ans = 0
       for (const x of bitmaskMap.keys()) {
           for (const y of bitmaskMap.keys()) {
               if ((x & y) == 0) {
                   ans = Math.max(ans, bitmaskMap.get(x) * bitmaskMap.get(y))
               }
           }
       }

       return ans
   };
    ```

#### 其他：
1. 用位来记录某个单词的出现，0 | 1
 
 


 
